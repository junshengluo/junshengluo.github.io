<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[探究 Android 开机画面]]></title>
      <url>%2F2016%2F11%2F26%2Fandroid-3-%E6%8E%A2%E7%A9%B6%20Android%20%E5%BC%80%E6%9C%BA%E7%94%BB%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[探究 Android 开机画面一，前言我们在前文探究Android OS 启动流程中曾有遗留问题 我们依次在屏幕上看到的各种logo、动画是什么?那个阶段现实的？ 下面我们就探究一下各种logo及动画出现的时机和展现原理。 二，关于开机画面由于Android是基于Linux 2.6版本的，所以在整个Android OS启动过程中，理论上会涉及到Linux内核的启动画面与静态画面，然后在原生真机Nexus 4上我们并没有看到传说中的小企鹅画面。由于技术限制每层探究到Linux Kernel层面，所以对于Linux内核层面的动画我们只是简单地说一下流程，方便理解以及过渡到我们Android层面的开机动画。我们先用一张图说一下开机画面的流程: 三，关于开机画面第一层动画 //TODO 有序研究到这层会补充完成 四，关于开机画面第二层动画 //TODO 有序研究到这层会补充完成 五，关于开机画面第三层动画下面我们来说说开机画面第三层动画，在源码涉及到的类有如下: 12./system/core/init/init.h./system/core/init/init.c 从上面涉及到的类我们就明白，这个画面应该是Init进程启动过程中出现的静态画面。我们记得在ini.c的main()函数中利用函数queue_builtin_action()，向init进程中的一个待执行队列(触发器为early-init)增加了一个名称等于”console_init”的action，这个action对应的执行函数为console_init_action(),它就是用来显示android层第二个开机画面的。我们先看一下 123456789101112131415int main(int argc, char **argv)&#123; .... init_parse_config_file("/init.rc"); .... //NOTE(ljs):执行rc文件中触发器为 on early-init的语句 action_for_each_trigger("early-init", action_add_queue_tail); .... //NOTE(ljs):向init进程中的一个待执行action队列增加了一个名称等于"console_init"的action //NOTE(ljs):这个action对应的执行函数为console_init_action,它就是用来显示android层第二个开机画面的 queue_builtin_action(console_init_action, "console_init"); ... //NOTE(ljs):执行rc文件中触发器为 on init的语句 action_for_each_trigger("init", action_add_queue_tail);&#125; 下面我们看一下action的执行函数console_init_action() 123456789101112131415161718192021222324252627static int console_init_action(int nargs, char **args)&#123; .... //NOTE(ljs):加载文件/initlogo.rle,若调用失败,将会显示文字的"ANDROID"logo if( load_565rle_image(INIT_IMAGE_FILE) ) &#123; fd = open("/dev/tty0", O_WRONLY); if (fd &gt;= 0) &#123; const char *msg; msg = "\n" "\n" "\n" "\n" "\n" "\n" "\n" // console is 40 cols x 30 lines "\n" "\n" "\n" "\n" "\n" " A N D R O I D "; write(fd, msg, strlen(msg)); close(fd); &#125; &#125; return 0;&#125; 关于宏命令INIT_IMAGE_FILE定义在: ./system/core/init/init.h 1#define INIT_IMAGE_FILE "/initlogo.rle" 也就是说Android层面的第二个开机画面的内容是由文件/initlogo.rle来指定的。如果文件/initlogo.rle不存在，或者在显示它的过程中出现异常，那么函数load_565rle_image()的返回值就会等于-1，这时候函数console_init_action()就以文本的方式来显示第二个开机画面，即向编号为0的控制台（/dev/tty0）输出“ANDROID”这7个字符。 NOTE/TODO:很不幸的是，依然没有看到这个画面（Nexus 4上/v4.4.2）. 六，关于开机画面第四层动画6.1 开机画面第四层动画的流程这层的画面，我相信很多人很熟悉了，是由bootanimation服务通过OpenGL来渲染画面。涉及到的主要源码文件如下: 123./frameworks/base/cmds/bootanimation/BootAnimation.cpp./frameworks/base/cmds/bootanimation/bootanimation_main.cpp./frameworks/base/cmds/bootanimation/BootAnimation.h 我们知道在Android OS启动的时候会启动SurfaceFlinger服务，关于SurfaceFlinger服务，请阅读罗升阳老师的Android系统Surface机制的SurfaceFlinger服务的启动过程分析，在SurfaceFlinger启动后，在SurfaceFlinger::init()函数中 1234567void SurfaceFlinger::init() &#123; ... // start boot animation //NOTE(ljs):SurfaceFlinger::init() –&gt; startBootAnim()-&gt;property_set("ctl.start", "bootanim"); startBootAnim();&#125; 看一下startBootAnim()函数 12345void SurfaceFlinger::startBootAnim() &#123; // start boot animation property_set("service.bootanim.exit", "0"); property_set("ctl.start", "bootanim");&#125; 我们看懂通过利用属性服务来启动开机动画服务bootanim，属性”ctl.start”和” ctl.stop”是用来启动和停止服务的. bootanim服务定义在init.rc中: 123456service bootanim /system/bin/bootanimation class main user graphics group graphics disabled oneshot 启动bootanimation进程，该进程的源码对应bootanimation_main.cpp，我们看一下主要代码: 123456789int main(int argc, char** argv)&#123; .... // create the boot animation object sp&lt;BootAnimation&gt; boot = new BootAnimation(); .... return 0;&#125; 然后我们看一下BootAnimation的构造 123456//NOTE(lsj):在构造函数中初始化mShutdown = false;表示默认是开机标志BootAnimation::BootAnimation() : Thread(false)&#123; //TODO(ljs):???什么鬼？以后研究 mSession = new SurfaceComposerClient();&#125; 然后我们在readyToRun()函数中看到了对于开机动画问题的判断 12#define USER_BOOTANIMATION_FILE "/data/local/bootanimation.zip"#define SYSTEM_BOOTANIMATION_FILE "/system/media/bootanimation.zip" 1234567891011121314151617181920status_t BootAnimation::readyToRun() &#123; .... //是否显示开机动画 mAndroidAnimation = true; // If the device has encryption turned on or is in process // of being encrypted we show the encrypted boot animation. char decrypt[PROPERTY_VALUE_MAX]; property_get("vold.decrypt", decrypt, ""); bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp("trigger_restart_min_framework", decrypt); if ((encryptedAnimation &amp;&amp; (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp; (mZip.open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE) == NO_ERROR))||...) &#123; mAndroidAnimation = false; &#125; return NO_ERROR;&#125; 主要是通过判断文件是否存在等逻辑来决定是否显示动画。真正的开始阶段如下: 123456789101112131415bool BootAnimation::threadLoop()&#123; bool r; if (mAndroidAnimation) &#123; //NOTE(ljs):执行android字体闪动的图片 r = android(); &#125; else &#123; //NOTE(ljs):执行bootanimation.zip中提供的动画图片 r = movie(); &#125; .... return r;&#125; 如果对bootanimation.zip的种种逻辑判断，得出结论是不播放动画时，就展示Android字体闪动的图片，如果可以播放动画，就播放bootanimation.zip提供的动画。 6.2 关于Android字体闪动的图片我们先看一下函数实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566bool BootAnimation::android()&#123; ALOGD("BootAnimation::android()"); //NOTE(ljs):/frameworks/base/core/res/assets/images/android-logo-mask.png //NOTE(ljs):/frameworks/base/core/res/assets/images/android-logo-shine.png initTexture(&amp;mAndroid[0], mAssets, "images/android-logo-mask.png"); initTexture(&amp;mAndroid[1], mAssets, "images/android-logo-shine.png"); // clear screen glShadeModel(GL_FLAT); glDisable(GL_DITHER); glDisable(GL_SCISSOR_TEST); glClearColor(0,0,0,1); glClear(GL_COLOR_BUFFER_BIT); eglSwapBuffers(mDisplay, mSurface); glEnable(GL_TEXTURE_2D); glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); const GLint xc = (mWidth - mAndroid[0].w) / 2; const GLint yc = (mHeight - mAndroid[0].h) / 2; const Rect updateRect(xc, yc, xc + mAndroid[0].w, yc + mAndroid[0].h); glScissor(updateRect.left, mHeight - updateRect.bottom, updateRect.width(), updateRect.height()); // Blend state glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); const nsecs_t startTime = systemTime(); do &#123; nsecs_t now = systemTime(); double time = now - startTime; float t = 4.0f * float(time / us2ns(16667)) / mAndroid[1].w; GLint offset = (1 - (t - floorf(t))) * mAndroid[1].w; GLint x = xc - offset; glDisable(GL_SCISSOR_TEST); glClear(GL_COLOR_BUFFER_BIT); glEnable(GL_SCISSOR_TEST); glDisable(GL_BLEND); glBindTexture(GL_TEXTURE_2D, mAndroid[1].name); glDrawTexiOES(x, yc, 0, mAndroid[1].w, mAndroid[1].h); glDrawTexiOES(x + mAndroid[1].w, yc, 0, mAndroid[1].w, mAndroid[1].h); glEnable(GL_BLEND); glBindTexture(GL_TEXTURE_2D, mAndroid[0].name); glDrawTexiOES(xc, yc, 0, mAndroid[0].w, mAndroid[0].h); EGLBoolean res = eglSwapBuffers(mDisplay, mSurface); if (res == EGL_FALSE) break; // 12fps: don't animate too fast to preserve CPU const nsecs_t sleepTime = 83333 - ns2us(systemTime() - now); if (sleepTime &gt; 0) usleep(sleepTime); checkExit(); &#125; while (!exitPending()); glDeleteTextures(1, &amp;mAndroid[0].name); glDeleteTextures(1, &amp;mAndroid[1].name); return false;&#125; 利用OpenGL把android-logo-mask.png和android-logo-shine.png展示。这两者图片具体位置: 12./frameworks/base/core/res/assets/images/android-logo-mask.png./frameworks/base/core/res/assets/images/android-logo-shine.png 我们看一下图片 是不是现在明白了什么… TODO OpenGL是如何把这2张图片呈现出来的？？？？？？？待研究 6.3 关于Android的bootanimation.zip动画我们先看一下具体函数实现: 12345bool BootAnimation::movie()&#123; .... //NOTE(ljs):OpenGL相关不作分析...&#125; 我们看一下到底bootanimation.zip文件是个什么样的文件。我已将把miui和优朋普乐的开机动画文件传至github。github-bootanimation 我们解压miui的会看到如下文件 12345678|--bootanimation |--part0 |-01.png |-02.png |-03.png |-04.png |-05.png |--desc.txt 当看到01-05.png的时候，我想大家就明白了，原来我们看到的动画是这5张图片的帧动画。而对于desc.txt 文件我们看一下内容: 121080 1920 5p 0 5 part0 对于这个描述文件我组一下说明: 121080 1920 5 ----这里的1080代表图片的像素（大小）宽度，1920代表图片的像素（大小）高度，5代表帧数，也就是图片一共多少张p 1 0 part0 ---这里的p代表标志符，1代表循环次数为1次，0代表阶段间隔时间为0,part0代表对应的文件夹名 对应voole的bootanimation.zip文件解压如下: 12345678910|--bootanimation |--part0 |-01.png |--part1 |-01.png |-02.png |-03.png |-04.png |-05.png |--desc.txt desc.txt描述如下: 1231280 720 3p 1 0 part0p 5 0 part1 如此我们看到这个bootanimation.zip帧动画的实现的灵活性。 七，开机画面的最后通过上面我们基本了解了整个开机画面的显示流程和实现细节(其实还有大量没研究…)。最后通过探究开机动画的内部实现，发现Android 涉及的知识面太庞大。努力学习…. TODO: 既然开机可以播放帧动画，能不是播放音频视频类呢？目前 音频已成功，视频未成功….由于不熟悉Media Server整体的架构，后期研究后不上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究 init.rc 脚本]]></title>
      <url>%2F2016%2F11%2F26%2Fandroid-2-%E6%8E%A2%E7%A9%B6%20init.rc%20%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[探究 init.rc 脚本一，前言我们在前文探究Android OS 启动流程中，曾说过，init进程解析init.rc脚本然后启动各种service，比如zygote、servicemanager等.下面我们来一探究竟。关于init.rc 源码在./system/core/rootdir/init.rc.其说明文件google也给出来了就在源码里./system/init/readme.txt，如果你英文比较好，基本可以略过这篇文章了。 二，关于init.rcinit.rc文件基本组成单位是section(段落)，section分为三种类型，分别用on,service,import关键字表示. 2.1 import 类型 主要作用: 表示引入另外一个xx.rc文件 语法: 1234import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.trace.rc 2.2 on 类型 主要作用: 表示一系列命令的组合(也就是Action类型): 语法: 1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; 2.3 service 类型 主要作用: 表示一个可执行程序 语法:表示一个可执行程序 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 三，关于init.rc 语句语法我们上面说了init.rc文件的基本组成单位是section，而上述的3中section只要有如下几种语句组成 3.1:Action(动作):表示了一组命令(commands)组成. Action包含一个trigger(触发器)，决定了何时执行这个动作; 当触发器的条件满足时,这个动作会被加入到已被执行的队列尾; 如果此动作在队列中已经存在,那么它将不会执行. 一个Action所包含的命令将被依次执行;动作的语法如下所示: 1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; 3.2:Commands:命令Commands 详见如下: 命令 描述 chmod &lt;octal-mode&gt; &lt;path&gt; 改变指定文件的读取权限 chown &lt;owner&gt; &lt;group&gt; &lt;path&gt; 改变指定文件的拥有都和组名的属性 chroot &lt;directory&gt; 改变进行的根目录 class_start &lt;serviceclass&gt; 启动指定类属的所有服务，如果服务已经启动，则不再重复启动 class_stop &lt;serviceclass&gt; 停止指定类属的所胡服务 domainname &lt;name&gt; 设置域名 export &lt;name&gt; &lt;value&gt; 设置全局环境参数，此参数被设置后对所有进程都有效 exec &lt;path&gt; [ &lt;argument&gt; ]* 执行指定路径下的程序，并传递参数 hostname &lt;name&gt; 设置主机名 ifup &lt;interface&gt; 使指定的网络接口”上线”，相当激活指定的网络接口 import &lt;filename&gt; 导入一个额外的init配置文件 insmod &lt;path&gt; 安装模块到指定路径 mkdir &lt;path&gt; [mode] [owner] [group] 用指定参数创建一个目录，在默认情况下，创建的目录读取权限为755，用户名为root，组名为root mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;mountoption&gt; ]* 类似于linux的mount指令 start &lt;service&gt; 如果指定的服务未启动，则启动它 stop &lt;service&gt; 如果指定的服务当前正在运行，则停止它 setprop &lt;name&gt; &lt;value&gt; 设置属性及对应的值 trigger &lt;event&gt; 触发器 write &lt;path&gt; &lt;string&gt; [ &lt;string&gt; ]* 往指定的文件写字符串 3.3:Services:服务是指那些需要在系统初始化时就启动或退出时自动重启的程序。它的语法结构如下所示: 1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... 3.4:OptionsOptions:用来修改服务的;它们影响如何及何时运行这个服务 选项 描述 critical 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。 disabled 服务不会自动运行，必须显式地通过服务器来启动。 setenv &lt;name&gt; &lt;value&gt; 设置环境变量 socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; ] ] 在/dev/socket/下创建一个unix domain的socket，并传递创建的文件描述符fd给服务进程.其中type必须为dgram或stream,seqpacket。用户名和组名默认为0 user &lt;username&gt; 在执行此服务之前先切换用户名。当前默认为root. oneshot 当此服务退出时不会自动重启. class &lt;name&gt; 给服务指定一个类属。这样方便操作多个服务同时启动或停止。默认情况下为default。 onrestart 当服务重启时执行一条指令 3.5:triggertrigger:触发器,或者叫做触发条件 触发器 描述 boot 当init程序执行，并载入/init.conf文件时触发. &lt;name&gt;=&lt;value&gt; 当属性名对应的值设置为指定值时触发. device-added-&lt;path&gt; 当添加设备时触发. device-removed-&lt;path&gt; 当设备移除时触发. service-exited-&lt;name&gt; 当指定的服务退出时触发. 四，语法的最后12341. 在init.rc文件中一条语句通常是占据一行;2. 单词之间是通过空格符来相隔的;3. 如果需要在单词内使用空格,那么得使用转义字符"\",如果在一行的末尾有一个反斜杠,那么是换行折叠符号,应该和下一行合并成一起来处理,这样做主要是为了避免一行的字符太长,与C语言中的含义是一致的;4. 注释是以#号开头;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解SSH协议]]></title>
      <url>%2F2016%2F11%2F25%2Fserver-%E7%90%86%E8%A7%A3SSH%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[理解SSH协议一，什么是SSH协议？SSH，全称Secure SHell protocol，即安全外壳协议，可以在不安全的网络环境里提供安全远程登录及其他安全网络服务的协议。 二，秘钥说明 公钥和私钥的关系类似解密。 在登录和验证时，都会同时用到这两个密钥。 公钥位于服务器上(远程位置)。 私钥位于本地计算机/服务器上。 当登录服务器时，两者将进行配对。 如果它们配对成功，您将可以登录到服务器上 用公钥认证是密码认证的一种替换方式。由于必须持有私钥才能认证，所有要想强行破解几乎是不可能的 三，SSH的工作原理 12345678910111213141516171819202122232425261. server启动sshd服务，生成公钥+私钥2. 客户端主动发送请求命令如下:&gt; $ ssh username@ip3. server响应请求，将公钥（????明文????）发给clientclient收到server的公钥后做了如下工作&gt;客户端记录并比对服务器的公钥数据及随机计算自己的公私钥 :&gt;若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的 ~/.ssh/known_hosts 。&gt;若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。&gt;若接受此公钥， 则开始计算客户端自己的公钥+私钥.4. clent将自己的公钥回传到server此时:&gt;server :具有自己的私钥和client的公钥;&gt;client :具有自己的私钥和server的公钥;&gt;你会看到，在此次联机的服务器与客户端的密钥系统 (公钥+私钥) 并不一样，所以才称为非对称加密系统。开始双向加解密:&gt;服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密;&gt;客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究 Android 属性服务]]></title>
      <url>%2F2016%2F11%2F25%2Fandroid-4-%E6%8E%A2%E7%A9%B6%20Android%20%E5%B1%9E%E6%80%A7%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[探究 Android 属性服务一，前言]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究Android OS 启动流程]]></title>
      <url>%2F2016%2F11%2F24%2Fandroid-1-%E6%8E%A2%E7%A9%B6Android%20OS%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[探究Android OS 启动流程一，前言为了更好地服务于Android应用层的开发，尝试理解整个Android OS系统的内部制、Android整个架构的思想以及各个模块的交互逻辑等等。Android系统涉及的层面过于复杂，从google官方的四层架构图(如下图)就能看出其复杂性.去深入理解每层每个模块的机制和原理不是一朝一夕的事,所以我们先从OS整个启动流程来窥探一二. NOTE:由于本人从源码Version4.4.2版本开始探索,博文中涉及到的具体类或者逻辑都是基于Android4.4.2,之所以没有探究最新的,是因为无论Android怎么迭代更新,其中内部机制的基本流程、骨干脉络大致相同的(也可能会有大的改动,比如Dalvik VM变成ART…). 二，理解Android启动过程我们试着探究OS启动流程时,我们总有很多疑问.我们带着问题去理解整个启动流程: 按下电源键到我们看到Android Launcher是一个怎么样的流程? 我们依次在屏幕上看到的各种logo、动画是什么?那个阶段现实的？ 我们写的app是怎么被安装到系统上的? 我们点击app的图标时又发生了什么? 等等… 我们先看一个大概的流程图,然后带着我的问题逐一去理解整个Android OS启动流程: tips:画图工具为Chrome 插件:gliffy 第一步:启动电源以及系统启动当我们按下电源后,引导芯片代码执行,然后加载引导程序到RAM执行. //TODO 这里面涉及到的BIOS/MBR等知识,不做探究…可以参考一下鸟哥的私房菜关于Linux的启动流程分析。因为Android是基于Linux2.6版本的，具体的流程可以参考一下。 第二步:Boot Loeader引导程序 在硬盘上第0磁道第一个扇区被称为MBR，即主引导记录，存放预启动信息以及分区表信息。 系统找到MBR后会将其复制到特定地址的物理内存中，物理内存上的内容就是 Boot Loeader; Boot Loeader的作用:检测外部的RAM以及加载一些有用的程序,设置网络、内存,初始化硬件(主板、键盘…)等,主要一点就是根据Boot Loeader内部的配置信息,找到内核镜像,然后将内核加载到内存. 第三步:Linux Kernel系统将内核加载到内存之后，并调用相关函数来启动一系列的初始化函数并初始化各种设备，比如设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init“文件，然后启动root进程或者系统的第一个进程。 第四步:init进程init是第一个进程。进程号为1。也是所有用户进程的父进程。 12shell@mako: # ps |grep init root 1 0 692 556 c012cbf0 0001a070 S /init init进程对应的文件./system/core/init/init.c,在其main()方法中我们可以看到主要有3个责任: 123* 挂载目录，比如比如/sys、/dev、/proc* 运行init.rc脚本* 提供属性服务 主要代码如下: 1234567891011121314151617181920212223242526272829303132int main(int argc, char **argv)&#123; .... mkdir("/dev", 0755); mkdir("/proc", 0755); mkdir("/sys", 0755); mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"); mkdir("/dev/pts", 0755); mkdir("/dev/socket", 0755); mount("devpts", "/dev/pts", "devpts", 0, NULL); mount("proc", "/proc", "proc", 0, NULL); mount("sysfs", "/sys", "sysfs", 0, NULL); ... klog_init();//初始化kernel log property_init();//创建一块共享的内存空间,用于属性服务property_service.c#property_init() ... //NOTE(ljs):即解析了这个脚本文件/init.rc,这个脚本文件在Android设备中 /init.rc, //NOTE(ljs):对应./system/core/rootdir/init.rc //NOTE(ljs):里面运行了大量的mkdir,chown,chmod,mount //NOTE(ljs):service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server //NOTE(ljs):开启service -Xzygote(孵化器=&gt;孵化整个世界), //NOTE(ljs):这个服务启动后启动后了app_process,对应的./frameworks/base/cmds/app_process/app_main.cpp //NOTE(ljs):我们发现runtime.start("com.android.internal.os.ZygoteInit",startSystemServer); INFO("&gt;&gt;&gt;init.c#main():--&gt;init_parse_config_file():解析/init.rc脚本\n"); init_parse_config_file("/init.rc"); ... ... return 0;&#125; 具体的关于init.rc脚本,请阅读探究 init.rc 脚本。 具体的关于属性服务,我们放在后面的博文中分析 //TODO 补充链接 init进程启动后会利用initr.rc孵化了Zygote进程,如下: 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 第五步:Zygote Zygote这个进程是非常重要的一个进程，Zygote进程的建立是真正的Android运行空间。我么利用ps命令可以看到关于Zygote进程的详细信息: 12shell@mako:/ # ps |grep zygote root 175 1 859220 41940 ffffffff 400ea6d8 S zygote Zygote,其最初的名字是app_process，通过直接调用pctrl把名字给改成了”Zygote”。 我们看一下其对应的源文件为:./frameworks/base/cmds/app_process/app_main.cpp 看一下其main()方法: 1234567891011121314151617int main(int argc, char* const argv[])&#123; .... AppRuntime runtime; ... if (zygote) &#123; //NOTE(ljs):AppRuntime runtime 即AndroidRuntime,在AndroidRuntime.cpp里有个start()---&gt;startVm() //NOTE(ljs):在ZygoteInit===&gt;main()中调用了方法startSystemServer( ); //NOTE(ljs):这个方法主要目的是加载了com.android.server.SystemServer.java //NOTE(ljs):这个类&lt;source-path&gt;/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java runtime.start("com.android.internal.os.ZygoteInit",startSystemServer ? "start-system-server" : ""); &#125; else&#123; ... &#125;&#125; 我们在看一下AndroidRuntime.cpp中的 1234567891011121314151617181920212223242526272829void AndroidRuntime::start(const char* className, const char* options)&#123; ... //NOTE(ljs):调用函数startVm()启动虚拟机 if (startVm(&amp;mJavaVM, &amp;env) != 0) &#123; return; &#125; onVmCreated(env); //NOTE(ljs):调用函数startReg()注册JNI方法 if (startReg(env) &lt; 0) &#123; ALOGE("Unable to register all android natives\n"); return; &#125; if (startClass == NULL) &#123; ... &#125; else &#123; ... if (startMeth == NULL) &#123; .... &#125; else &#123; //NOTE(ljs):调用了com.android.internal.os.ZygoteInit类的main()函数 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ...... &#125; &#125; ...&#125; 主要做了如下几个工作: 启动虚拟机 注册JNI 调用了com.android.internal.os.ZygoteInit类的main()函数 什么是AndroidRuntime？我们从上面Android体系架构图中可以看出，其就是为Android应用运行所需的运行时环境，包括Dalvik VM以及核心类库(java、JNI、libc等) 我们继续探究ZygoteInit.java的main(),主要工作已在代码中表明: 12345678910111213141516171819public static void main(String argv[]) &#123; ... //NOTE(ljs):创建了一个socket接口,用来和ActivityManagerService通讯 registerZygoteSocket(); ... //NOTE(ljs):来启动SystemServer组件 startSystemServer(); ... //NOTE(ljs):调用runSelectLoopMode函数进入一个无限循环在前面创建的socket接口上等待ActivityManagerService请求创建新的应用程序进程 runSelectLoop(); ... &#125; //TODO Zygote是处于什么目的提出来的？ 第六步:SystemServer我们继续分析SystemServer的main()方法: 123456789public static void main(String[] args) &#123; .... // NOTE(ljs):传说中的init1():开启了Native世界 nativeInit(); ... // NOTE(ljs):传说中的init2():开启java世界 ServerThread thr = new ServerThread(); thr.initAndLoop();&#125; 关于开启Native世界:见.frameworks/base/services/jni/com_android_server_SystemServer.cpp 12345678static void android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) &#123; char propBuf[PROPERTY_VALUE_MAX]; property_get("system_init.startsensorservice", propBuf, "1"); if (strcmp(propBuf, "1") == 0) &#123; // Start the sensor service SensorService::instantiate(); &#125;&#125; 作为应用层开发人员我们重点看一下传说中的init2():ServerThread.initAndLoop() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void initAndLoop() &#123; ... Looper.prepareMainLooper(); ... //NOTE(ljs):创建各种服务实例,初始化完成以后加入到ServiceManager中 Installer installer = null; .... IPackageManager pm = null;//包管理服务 Context context = null; //窗口管理系统服务 WindowManagerService wm = null; ... HandlerThread wmHandlerThread = new HandlerThread("WindowManager"); wmHandlerThread.start(); Handler wmHandler = new Handler(wmHandlerThread.getLooper()); wmHandler.post(new Runnable() &#123; @Override public void run() &#123; //Looper.myLooper().setMessageLogging(new LogPrinter(android.util.Log.DEBUG, TAG, android.util.Log.LOG_ID_SYSTEM)); android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DISPLAY); android.os.Process.setCanSelfBackground(false); // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, "Enabled StrictMode logging for WM Looper"); &#125; &#125; &#125;); ... //NOTE(ljs):通过线程(类AThread)初始化ActivityManagerService实例以及其他实例 context = ActivityManagerService.main(factoryTest); ... //NOTE(ljs):创建了一个PackageManagerService服务实例,然后把这个服务添加到ServiceManager中去 pm = PackageManagerService.main(context, installer, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore); ... //NOTE(ljs):ActivityManagerService作为ApplicationFramework最重要的服务 ActivityManagerService.setSystemProcess(); ... //NOTE(ljs):系统服务初始化准备就绪,通知各个模块 Slog.d("xxoo","ActivityManagerService.self().systemReady(Runnable r)系统服务初始化准备就绪,通知各个模块"); ActivityManagerService.self().systemReady(new Runnable() &#123; public void run() &#123; .... //NOTE(ljs):启动com.android.systemui startSystemUi(contextF); .... &#125; &#125;); ....&#125; 我们看到一大堆的服务和Manager,初始化服务,创建各种服务实例,如:电源、网络、Wifi、蓝牙，USB等,初始化完成以后加入到ServiceManager中，在系统服务器准备就绪后，调用startSystemUi()启动com.android.systemui服务，开始做一些与SystemBars、Recents、SettingsUI等先关工作。 关于com.android.systemui服务对应的是com.android.systemui.SystemUIService。源码路径为:/frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIService.javaTODO 关于这部分我们后续分析 下面我们进去ActivityManagerService.systemReady()看一看: 123456789101112131415public void systemReady(final Runnable goingCallback) &#123; .... //NOTE(ljs):android.intent.action.PRE_BOOT_COMPLETED这个广播是在核心系统启动完成后, //NOTE(ljs):在launcher启动前或在BOOT_COMPLETED广播发出前发出的广播 .... Intent intent = new Intent(Intent.ACTION_PRE_BOOT_COMPLETED); //NOTE(ljs):FLAG_RECEIVER_BOOT_UPGRADE这个标记位意味着什么？ intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE); .... //NOTE(ljs):内部调用了ActivityStack.resumeTopActivityLocked--&gt;ActivityStack.resumeTopActivityLocked()--&gt; //--&gt;ActivityStackSupervisor.resumeHomeActivity()--&gt;mService.startHomeActivityLocked() //这里的mService即AMS mStackSupervisor.resumeTopActivitiesLocked(); sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);&#125; 发送了android.intent.action.PRE_BOOT_COMPLETED广播，调用ActivityStack.resumeTopActivityLocked()，我们继续跟踪到ActivityStack.resumeTopActivityLocked(): 12345678910111213141516171819final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; .... .... // Find the first activity that is not finishing. // NOTE(ljs):调用函数topRunningActivityLocked返回的是当前系统Activity堆栈最顶端的Activity, // NOTE(ljs):由于此时还没有Activity被启动过,因此,返回值为null,即next变量的值为nul ActivityRecord next = topRunningActivityLocked(null); .... if (next == null) &#123; .... //NOTE(ljs):调用了ActivityStackSupervisor.resumeHomeActivity() return mStackSupervisor.resumeHomeActivity(prev); &#125; .... ....&#125; 最红我们由ActivityStackSupervisor.resumeHomeActivity()–&gt;AMS.startHomeActivityLocked()，我们分析一下这里面有我们要找的关键代码: 123456789101112131415161718192021222324boolean startHomeActivityLocked(int userId) &#123; ... //NOTE(ljs):发送开机广播 ensureBootCompleted(); .... //NOTE(ljs):1.获取一个CATEGORY_HOME类型的Intent;android.intent.category.HOME Intent intent = getHomeIntent(); //NOTE(ljs):2.向PackageManagerService查询Category类型为HOME的Activity ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //NOTE(ljs): 启动activity mStackSupervisor.startHomeActivity(intent, aInfo); &#125; &#125; return true;&#125; 函数首先通过getHomeIntent()获取一个android.intent.category.HOME类型的Intent,然后通过Intent.resolveActivityInfo函数向PackageManagerService查询Category类型为HOME的Activity，然后启动Activity。关于如何利用隐式意图启动Activity这里就不做讨论了。我们看一下Launcher的注册信息，详见/packages/apps/Launcher2/AndroidManifest.xml: 12345678910111213141516&lt;activity android:name="com.android.launcher2.Launcher" android:clearTaskOnLaunch="true" android:launchMode="singleTask" android:screenOrientation="nosensor" android:stateNotNeeded="true" android:theme="@style/Theme" android:windowSoftInputMode="adjustPan"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.HOME"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.MONKEY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; OK，到此为止，我们分析到了AMS—&gt;启动Launcher。 第七步:Launcher的启动关于Launcher启动的细节以及UI方面的细节，因为涉及到的方面比较多，我会单独分析。应用层开发天天瞅着Launcher，还是需要了解一下其UI布局，管理机制等方面的。 //TODO 后续分析…… 第八步:我们自身的app的安装与启动//TODO 后续分析…… NOTE 文章仅仅是分析了大体的流程和一小部分细节。还有大量的细节没有关注到，比如Init.rc、开机动画是怎么回事等等，我会在后期另开博文，并把链接加上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo -next 如何设置首页显示预览]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E9%A2%84%E8%A7%88%2F</url>
      <content type="text"><![CDATA[##hexo -next 如何设置首页显示预览 一，设置头像在next主题的_config.yml文件中，查找auto_excerpt，找到如下部分: 1234# Automatically Excerptauto_excerpt:enable: falselength: 150 只要把这个enable 改为true就可以实现首页显示预览，而不用全部显示.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 优化篇]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
      <content type="text"><![CDATA[##hexo 优化篇 ###一,设置头像在配置文件中添加: 1avatar: https://avatars3.githubusercontent.com/u/10328555?v=3&amp;s=460 # 头像的URL ###一,搜索引擎优化(SEO)添加百度主动推送代码,让搜索引擎最快发现文章. ###一,必备插件支持RSS：npm install hexo-generator-feed –save生成站点地图：npm install hexo-generator-sitemap –save生成百度站点地图：npm install hexo-generator-baidu-sitemap –saveHTML 压缩：npm install hexo-html-minifier –saveJavaScript 压缩：npm install hexo-uglify –saveCSS 压缩插件：npm install hexo-clean-css –saveSEO优化：npm install hexo-generator-seo-friendly-sitemap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 安装插件]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[##hexo 安装插件 ###一,sitemapsitemap是一种协议,他会让搜索引擎更好的收录你的网站;也是SEO (Search Engine Optimization)中的一个关键选项;安装命令如下: 1$ npm install hexo-generator-sitemap 修改_config.yml,添加如下内容: 1234567891011121314# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml ###二,feed//TODO …. ###三,多说评论 为博客集成评论系统,一般用多说.Hexo使用多说教程 ###四,cnzz统计/百度统计统计分析网站流量插件 ###五,JiaThis分享官方网站 六，图片储存–七牛七牛 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何搭建github pages+hexo博客]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAgithub-pages-hexo-%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[##利用Github Pages和Hexo搭建个人博客 ###一,安装git ###二,注册github账号 ###三,安装node.js node.js中文网站 node.js官网 ###四,了解Hexo Hexo官方文档 ###五,安装Hexo 12# 使用 npm 安装 Hexonpm install -g hexo-cli 安装查看一下版本: 1hexo version或 hexo v ###五,使用hexo创建项目12345678cd ~/githubhexo init hexo #执行init命令初始化到你指定的hexo目录cd hexo npm install #install before start blogginghexo generate #自动根据当前目录下文件,生成静态网页hexo server #运行本地服务hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 Terminal 提示如下: 123bogon:hexo luojunsheng$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 在本地跑一下hexo,在浏览器输入: 1http://localhost:4000/ 到此,我们在网页中看到了我们的blog(本地运行). ###六,添加部署代码在站点的-config.yml文件新增字段如下字段,讲Deployment站点部署到github 1234deploy: type: git repository: https://github.com/username/username.github.io.git branch: master 我的github为https://github.com/junshengluo/junshengluo.github.io然后部署 12$ hexo g$ hexo d 如果出现下面的错误: 1Deployer not found: git 请运行如下命令: 1npm install hexo-deployer-git --save 然后访问浏览器:1username.github.io ###7,购买域名 阿里云 dnspod godaddy ###8,域名解析,讲域名指向github Pages 在source文件夹中新建一个CNAME文件(无后缀名),然后用文本编辑器打开,在首行添加你的网站域名,如http://xxxx.com,注意前面没有http://,也没有www. 在域名解析提供商 先添加一个CNAME,主机记录写@,后面记录值写上你的http://xxxx.github.io 再添加一个CNAME,主机记录写www,后面记录值也是http://xxxx.github.io 这样别人用www和不用www都能访问你的网站.也可以使用A记录,对应的记录值位github page的ip 等1分钟左右,刷新浏览器 1234@ A 192.30.252.153@ A 192.30.252.154@ CNAME username.github.iowww CNAME username.github.io.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何让wordpress支持代码缩进和高亮]]></title>
      <url>%2F2016%2F11%2F23%2Fwordpress-%E5%A6%82%E4%BD%95%E8%AE%A9wordpress%E6%94%AF%E6%8C%81%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E5%92%8C%E9%AB%98%E4%BA%AE%2F</url>
      <content type="text"><![CDATA[##如何让wordpress支持代码缩进和高亮? wordpress的默认编辑器不支持代码代码缩进和高亮,需要插件WP Code Highlight支持 插件的下载 下载地址:https://wordpress.org/plugins/wp-code-highlight/ 下载后解压得到wp-code-highlight文件夹，上传至 /wp-content/plugins/ 目录，然后在后台“插件”那里启用。 对插件进行个性化的设置方法:登入后→设置→WP Code Highlight。 写文章时将代码放在&lt;pre&gt;和&lt;/pre&gt;中间即可 NOTE:Html编辑器中已经提供了一个名为WP-Code-Highlight的按钮，方便你插入代码 5.WP Code Highlight代码高亮演示 12345678910/** * Gets whether the TextView includes extra top and bottom padding to make * room for accents that go above the normal ascent and descent. * * @attr ref android.R.styleable#TextView_includeFontPadding * @see #setIncludeFontPadding(boolean) */public boolean getIncludeFontPadding() &#123; return mIncludePad;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F23%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
