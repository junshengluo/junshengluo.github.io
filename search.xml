<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[探究 init.rc 脚本]]></title>
      <url>%2F2016%2F11%2F26%2F%E6%8E%A2%E7%A9%B6%20init.rc%20%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[探究 init.rc 脚本一，前言我们在前文探究Android OS 启动流程中，曾说过，init进程解析init.rc脚本然后启动各种service，比如zygote、servicemanager等.下面我们来一探究竟。关于init.rc 源码在./system/core/rootdir/init.rc，他的说明文件google也给出来了就在源码里./system/init/readme.txt，如果你英文比较好，基本可以略过这篇文章了。 二，关于init.rcinit.rc文件基本组成单位是section(段落)，section分为三种类型，分别用on,service,import关键字表示. import 类型 主要作用: 表示引入另外一个xx.rc文件 语法: 1234import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.trace.rc on 类型 主要作用: 表示一系列命令的组合(也就是Action类型): 语法: 1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; service 类型 主要作用: 表示一个可执行程序 语法:表示一个可执行程序 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 三，关于init.rc 语句语法我们上面说了init.rc文件的基本组成单位是section，而上述的3中section只要有如下几种语句组成 3.1 Action(动作):表示了一组命令(commands)组成. Action包含一个trigger(触发器)，决定了何时执行这个动作; 当触发器的条件满足时,这个动作会被加入到已被执行的队列尾; 如果此动作在队列中已经存在,那么它将不会执行. 一个Action所包含的命令将被依次执行;动作的语法如下所示: 1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; Commands:命令Commands 详见如下:|命令|描述|| ————- |:————-:||chmod |改变指定文件的读取权限.||start |如果指定的服务未启动，则启动它||stop |如果指定的服务当前正在运行，则停止它| Services:Options:用来修改服务的;它们影响如何及何时运行这个服务 trigger:触发器,或者叫做触发条件四， 语法的最后12341. 在init.rc文件中一条语句通常是占据一行;2. 单词之间是通过空格符来相隔的;3. 如果需要在单词内使用空格,那么得使用转义字符&quot;\&quot;,如果在一行的末尾有一个反斜杠,那么是换行折叠符号,应该和下一行合并成一起来处理,这样做主要是为了避免一行的字符太长,与C语言中的含义是一致的;4. 注释是以#号开头;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解SSH协议]]></title>
      <url>%2F2016%2F11%2F25%2F%E7%90%86%E8%A7%A3SSH%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[理解SSH协议一，什么是SSH协议？SSH，全称Secure SHell protocol，即安全外壳协议，可以在不安全的网络环境里提供安全远程登录及其他安全网络服务的协议。 二，秘钥说明 公钥和私钥的关系类似解密。 在登录和验证时，都会同时用到这两个密钥。 公钥位于服务器上(远程位置)。 私钥位于本地计算机/服务器上。 当登录服务器时，两者将进行配对。 如果它们配对成功，您将可以登录到服务器上 用公钥认证是密码认证的一种替换方式。由于必须持有私钥才能认证，所有要想强行破解几乎是不可能的 三，SSH的工作原理 12345678910111213141516171819202122232425261. server启动sshd服务，生成公钥+私钥2. 客户端主动发送请求命令如下:&gt; $ ssh username@ip3. server响应请求，将公钥（????明文????）发给clientclient收到server的公钥后做了如下工作&gt;客户端记录并比对服务器的公钥数据及随机计算自己的公私钥 :&gt;若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的 ~/.ssh/known_hosts 。&gt;若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。&gt;若接受此公钥， 则开始计算客户端自己的公钥+私钥.4. clent将自己的公钥回传到server此时:&gt;server :具有自己的私钥和client的公钥;&gt;client :具有自己的私钥和server的公钥;&gt;你会看到，在此次联机的服务器与客户端的密钥系统 (公钥+私钥) 并不一样，所以才称为非对称加密系统。开始双向加解密:&gt;服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密;&gt;客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究Android OS 启动流程]]></title>
      <url>%2F2016%2F11%2F24%2F%E6%8E%A2%E7%A9%B6Android%20OS%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[探究Android OS 启动流程一，前言为了更好地服务于Android应用层的开发，尝试理解整个Android OS系统的内部制、Android整个架构的思想以及各个模块的交互逻辑等等。Android系统涉及的层面过于复杂，从google官方的四层架构图(如下图)就能看出其复杂性.去深入理解每层每个模块的机制和原理不是一朝一夕的事,所以我们先从OS整个启动流程来窥探一二. NOTE:由于本人从源码Version4.4.2版本开始探索,博文中涉及到的具体类或者逻辑都是基于Android4.4.2,之所以没有探究最新的,是因为无论Android怎么迭代更新,其中内部机制的基本流程、骨干脉络大致相同的(也可能会有大的改动,比如Dalvik VM变成ART…). 二，理解Android启动过程我们试着探究OS启动流程时,我们总有很多疑问.我们带着问题去理解整个启动流程: 按下电源键到我们看到Android Launcher是一个怎么样的流程? 我们依次在屏幕上看到的各种logo、动画是什么?那个阶段现实的？ 我们写的app是怎么被安装到系统上的? 我们点击app的图标时又发生了什么? 等等… 我们先看一个大概的流程图,然后带着我的问题逐一去理解整个Android OS启动流程: tips:画图工具为Chrome 插件:gliffy 第一步:启动电源以及系统启动当我们按下电源后,引导芯片代码执行,然后加载引导程序到RAM执行. //TODO 这里面涉及到的BIOS/MBR等知识,不做探究…可以参考一下鸟哥的私房菜关于Linux的启动流程分析。因为Android是基于Linux2.6版本的，具体的流程可以参考一下。 第二步:Boot Loeader引导程序 在硬盘上第0磁道第一个扇区被称为MBR，即主引导记录，存放预启动信息以及分区表信息。 系统找到MBR后会将其复制到特定地址的物理内存中，物理内存上的内容就是 Boot Loeader; Boot Loeader的作用:检测外部的RAM以及加载一些有用的程序,设置网络、内存,初始化硬件(主板、键盘…)等,主要一点就是根据Boot Loeader内部的配置信息,找到内核镜像,然后将内核加载到内存. 第三步:Linux Kernel系统将内核加载到内存之后，并调用相关函数来启动一系列的初始化函数并初始化各种设备，比如设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init“文件，然后启动root进程或者系统的第一个进程。 第四步:init进程init是第一个进程。进程号为1。也是所有用户进程的父进程。 12shell@mako: # ps |grep init root 1 0 692 556 c012cbf0 0001a070 S /init init进程对应的文件./system/core/init/init.c,在其main()方法中我们可以看到主要有3个责任: 123* 挂载目录，比如比如/sys、/dev、/proc* 运行init.rc脚本* 提供属性服务 主要代码如下: 1234567891011121314151617181920212223242526272829303132int main(int argc, char **argv)&#123; .... mkdir("/dev", 0755); mkdir("/proc", 0755); mkdir("/sys", 0755); mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"); mkdir("/dev/pts", 0755); mkdir("/dev/socket", 0755); mount("devpts", "/dev/pts", "devpts", 0, NULL); mount("proc", "/proc", "proc", 0, NULL); mount("sysfs", "/sys", "sysfs", 0, NULL); ... klog_init();//初始化kernel log property_init();//创建一块共享的内存空间,用于属性服务property_service.c#property_init() ... //NOTE(ljs):即解析了这个脚本文件/init.rc,这个脚本文件在Android设备中 /init.rc, //NOTE(ljs):对应./system/core/rootdir/init.rc //NOTE(ljs):里面运行了大量的mkdir,chown,chmod,mount //NOTE(ljs):service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server //NOTE(ljs):开启service -Xzygote(孵化器=&gt;孵化整个世界), //NOTE(ljs):这个服务启动后启动后了app_process,对应的./frameworks/base/cmds/app_process/app_main.cpp //NOTE(ljs):我们发现runtime.start("com.android.internal.os.ZygoteInit",startSystemServer); INFO("&gt;&gt;&gt;init.c#main():--&gt;init_parse_config_file():解析/init.rc脚本\n"); init_parse_config_file("/init.rc"); ... ... return 0;&#125; 具体的关于init.rc脚本和属性服务,我们放在后面的博文中分析 //TODO 补充链接 init进程启动后会利用initr.rc孵化了Zygote进程,如下: 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 第五步:Zygote Zygote这个进程是非常重要的一个进程，Zygote进程的建立是真正的Android运行空间。我么利用ps命令可以看到关于Zygote进程的详细信息: 12shell@mako:/ # ps |grep zygote root 175 1 859220 41940 ffffffff 400ea6d8 S zygote Zygote,其最初的名字是app_process，通过直接调用pctrl把名字给改成了”Zygote”。 我们看一下其对应的源文件为:./frameworks/base/cmds/app_process/app_main.cpp 看一下其main()方法: 1234567891011121314151617int main(int argc, char* const argv[])&#123; .... AppRuntime runtime; ... if (zygote) &#123; //NOTE(ljs):AppRuntime runtime 即AndroidRuntime,在AndroidRuntime.cpp里有个start()---&gt;startVm() //NOTE(ljs):在ZygoteInit===&gt;main()中调用了方法startSystemServer( ); //NOTE(ljs):这个方法主要目的是加载了com.android.server.SystemServer.java //NOTE(ljs):这个类&lt;source-path&gt;/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java runtime.start("com.android.internal.os.ZygoteInit",startSystemServer ? "start-system-server" : ""); &#125; else&#123; ... &#125;&#125; 我们在看一下AndroidRuntime.cpp中的 1234567891011121314151617181920212223242526272829void AndroidRuntime::start(const char* className, const char* options)&#123; ... //NOTE(ljs):调用函数startVm()启动虚拟机 if (startVm(&amp;mJavaVM, &amp;env) != 0) &#123; return; &#125; onVmCreated(env); //NOTE(ljs):调用函数startReg()注册JNI方法 if (startReg(env) &lt; 0) &#123; ALOGE("Unable to register all android natives\n"); return; &#125; if (startClass == NULL) &#123; ... &#125; else &#123; ... if (startMeth == NULL) &#123; .... &#125; else &#123; //NOTE(ljs):调用了com.android.internal.os.ZygoteInit类的main()函数 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ...... &#125; &#125; ...&#125; 主要做了如下几个工作: 启动虚拟机 注册JNI 调用了com.android.internal.os.ZygoteInit类的main()函数 什么是AndroidRuntime？我们从上面Android体系架构图中可以看出，其就是为Android应用运行所需的运行时环境，包括Dalvik VM以及核心类库(java、JNI、libc等) 我们继续探究ZygoteInit.java的main(),主要工作已在代码中表明: 12345678910111213141516171819public static void main(String argv[]) &#123; ... //NOTE(ljs):创建了一个socket接口,用来和ActivityManagerService通讯 registerZygoteSocket(); ... //NOTE(ljs):来启动SystemServer组件 startSystemServer(); ... //NOTE(ljs):调用runSelectLoopMode函数进入一个无限循环在前面创建的socket接口上等待ActivityManagerService请求创建新的应用程序进程 runSelectLoop(); ... &#125; //TODO Zygote是处于什么目的提出来的？ 第六步:SystemServer我们继续分析SystemServer的main()方法: 123456789public static void main(String[] args) &#123; .... // NOTE(ljs):传说中的init1():开启了Native世界 nativeInit(); ... // NOTE(ljs):传说中的init2():开启java世界 ServerThread thr = new ServerThread(); thr.initAndLoop();&#125; 关于开启Native世界:见.frameworks/base/services/jni/com_android_server_SystemServer.cpp 12345678static void android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) &#123; char propBuf[PROPERTY_VALUE_MAX]; property_get("system_init.startsensorservice", propBuf, "1"); if (strcmp(propBuf, "1") == 0) &#123; // Start the sensor service SensorService::instantiate(); &#125;&#125; 作为应用层开发人员我们重点看一下传说中的init2():ServerThread.initAndLoop() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void initAndLoop() &#123; ... Looper.prepareMainLooper(); ... //NOTE(ljs):创建各种服务实例,初始化完成以后加入到ServiceManager中 Installer installer = null; .... IPackageManager pm = null;//包管理服务 Context context = null; //窗口管理系统服务 WindowManagerService wm = null; ... HandlerThread wmHandlerThread = new HandlerThread("WindowManager"); wmHandlerThread.start(); Handler wmHandler = new Handler(wmHandlerThread.getLooper()); wmHandler.post(new Runnable() &#123; @Override public void run() &#123; //Looper.myLooper().setMessageLogging(new LogPrinter(android.util.Log.DEBUG, TAG, android.util.Log.LOG_ID_SYSTEM)); android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DISPLAY); android.os.Process.setCanSelfBackground(false); // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, "Enabled StrictMode logging for WM Looper"); &#125; &#125; &#125;); ... //NOTE(ljs):通过线程(类AThread)初始化ActivityManagerService实例以及其他实例 context = ActivityManagerService.main(factoryTest); ... //NOTE(ljs):创建了一个PackageManagerService服务实例,然后把这个服务添加到ServiceManager中去 pm = PackageManagerService.main(context, installer, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore); ... //NOTE(ljs):ActivityManagerService作为ApplicationFramework最重要的服务 ActivityManagerService.setSystemProcess(); ... //NOTE(ljs):系统服务初始化准备就绪,通知各个模块 Slog.d("xxoo","ActivityManagerService.self().systemReady(Runnable r)系统服务初始化准备就绪,通知各个模块"); ActivityManagerService.self().systemReady(new Runnable() &#123; public void run() &#123; .... //NOTE(ljs):启动com.android.systemui startSystemUi(contextF); .... &#125; &#125;); ....&#125; 我们看到一大堆的服务和Manager,初始化服务,创建各种服务实例,如:电源、网络、Wifi、蓝牙，USB等,初始化完成以后加入到ServiceManager中，在系统服务器准备就绪后，调用startSystemUi()启动com.android.systemui服务，开始做一些与SystemBars、Recents、SettingsUI等先关工作。 关于com.android.systemui服务对应的是com.android.systemui.SystemUIService。源码路径为:/frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIService.javaTODO 关于这部分我们后续分析 下面我们进去ActivityManagerService.systemReady()看一看: 123456789101112131415public void systemReady(final Runnable goingCallback) &#123; .... //NOTE(ljs):android.intent.action.PRE_BOOT_COMPLETED这个广播是在核心系统启动完成后, //NOTE(ljs):在launcher启动前或在BOOT_COMPLETED广播发出前发出的广播 .... Intent intent = new Intent(Intent.ACTION_PRE_BOOT_COMPLETED); //NOTE(ljs):FLAG_RECEIVER_BOOT_UPGRADE这个标记位意味着什么？ intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE); .... //NOTE(ljs):内部调用了ActivityStack.resumeTopActivityLocked--&gt;ActivityStack.resumeTopActivityLocked()--&gt; //--&gt;ActivityStackSupervisor.resumeHomeActivity()--&gt;mService.startHomeActivityLocked() //这里的mService即AMS mStackSupervisor.resumeTopActivitiesLocked(); sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);&#125; 发送了android.intent.action.PRE_BOOT_COMPLETED广播，调用ActivityStack.resumeTopActivityLocked()，我们继续跟踪到ActivityStack.resumeTopActivityLocked(): 12345678910111213141516171819final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; .... .... // Find the first activity that is not finishing. // NOTE(ljs):调用函数topRunningActivityLocked返回的是当前系统Activity堆栈最顶端的Activity, // NOTE(ljs):由于此时还没有Activity被启动过,因此,返回值为null,即next变量的值为nul ActivityRecord next = topRunningActivityLocked(null); .... if (next == null) &#123; .... //NOTE(ljs):调用了ActivityStackSupervisor.resumeHomeActivity() return mStackSupervisor.resumeHomeActivity(prev); &#125; .... ....&#125; 最红我们由ActivityStackSupervisor.resumeHomeActivity()–&gt;AMS.startHomeActivityLocked()，我们分析一下这里面有我们要找的关键代码: 123456789101112131415161718192021222324boolean startHomeActivityLocked(int userId) &#123; ... //NOTE(ljs):发送开机广播 ensureBootCompleted(); .... //NOTE(ljs):1.获取一个CATEGORY_HOME类型的Intent;android.intent.category.HOME Intent intent = getHomeIntent(); //NOTE(ljs):2.向PackageManagerService查询Category类型为HOME的Activity ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //NOTE(ljs): 启动activity mStackSupervisor.startHomeActivity(intent, aInfo); &#125; &#125; return true;&#125; 函数首先通过getHomeIntent()获取一个android.intent.category.HOME类型的Intent,然后通过Intent.resolveActivityInfo函数向PackageManagerService查询Category类型为HOME的Activity，然后启动Activity。关于如何利用隐式意图启动Activity这里就不做讨论了。我们看一下Launcher的注册信息，详见/packages/apps/Launcher2/AndroidManifest.xml: 12345678910111213141516&lt;activity android:name="com.android.launcher2.Launcher" android:clearTaskOnLaunch="true" android:launchMode="singleTask" android:screenOrientation="nosensor" android:stateNotNeeded="true" android:theme="@style/Theme" android:windowSoftInputMode="adjustPan"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.HOME"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.MONKEY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; OK，到此为止，我们分析到了AMS—&gt;启动Launcher。 第七步:Launcher的启动关于Launcher启动的细节以及UI方面的细节，因为涉及到的方面比较多，我会单独分析。应用层开发天天瞅着Launcher，还是需要了解一下其UI布局，管理机制等方面的。 //TODO 后续分析…… 第八步:我们自身的app的安装与启动//TODO 后续分析…… NOTE 文章仅仅是分析了大体的流程和一小部分细节。还有大量的细节没有关注到，比如Init.rc、开机动画是怎么回事等等，我会在后期另开博文，并把链接加上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo -next 如何设置首页显示预览]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E9%A2%84%E8%A7%88%2F</url>
      <content type="text"><![CDATA[##hexo -next 如何设置首页显示预览 一，设置头像在next主题的_config.yml文件中，查找auto_excerpt，找到如下部分: 1234# Automatically Excerptauto_excerpt:enable: falselength: 150 只要把这个enable 改为true就可以实现首页显示预览，而不用全部显示.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 优化篇]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
      <content type="text"><![CDATA[##hexo 优化篇 ###一,设置头像在配置文件中添加: 1avatar: https://avatars3.githubusercontent.com/u/10328555?v=3&amp;s=460 # 头像的URL ###一,搜索引擎优化(SEO)添加百度主动推送代码,让搜索引擎最快发现文章. ###一,必备插件支持RSS：npm install hexo-generator-feed –save生成站点地图：npm install hexo-generator-sitemap –save生成百度站点地图：npm install hexo-generator-baidu-sitemap –saveHTML 压缩：npm install hexo-html-minifier –saveJavaScript 压缩：npm install hexo-uglify –saveCSS 压缩插件：npm install hexo-clean-css –saveSEO优化：npm install hexo-generator-seo-friendly-sitemap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 安装插件]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[##hexo 安装插件 ###一,sitemapsitemap是一种协议,他会让搜索引擎更好的收录你的网站;也是SEO (Search Engine Optimization)中的一个关键选项;安装命令如下: 1$ npm install hexo-generator-sitemap 修改_config.yml,添加如下内容: 1234567891011121314# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml ###二,feed//TODO …. ###三,多说评论 为博客集成评论系统,一般用多说.Hexo使用多说教程 ###四,cnzz统计/百度统计统计分析网站流量插件 ###五,JiaThis分享官方网站 六，图片储存–七牛七牛 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何搭建github pages+hexo博客]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAgithub-pages-hexo-%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[##利用Github Pages和Hexo搭建个人博客 ###一,安装git ###二,注册github账号 ###三,安装node.js node.js中文网站 node.js官网 ###四,了解Hexo Hexo官方文档 ###五,安装Hexo 12# 使用 npm 安装 Hexonpm install -g hexo-cli 安装查看一下版本: 1hexo version或 hexo v ###五,使用hexo创建项目12345678cd ~/githubhexo init hexo #执行init命令初始化到你指定的hexo目录cd hexo npm install #install before start blogginghexo generate #自动根据当前目录下文件,生成静态网页hexo server #运行本地服务hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 Terminal 提示如下: 123bogon:hexo luojunsheng$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 在本地跑一下hexo,在浏览器输入: 1http://localhost:4000/ 到此,我们在网页中看到了我们的blog(本地运行). ###六,添加部署代码在站点的-config.yml文件新增字段如下字段,讲Deployment站点部署到github 1234deploy: type: git repository: https://github.com/username/username.github.io.git branch: master 我的github为https://github.com/junshengluo/junshengluo.github.io然后部署 12$ hexo g$ hexo d 如果出现下面的错误: 1Deployer not found: git 请运行如下命令: 1npm install hexo-deployer-git --save 然后访问浏览器:1username.github.io ###7,购买域名 阿里云 dnspod godaddy ###8,域名解析,讲域名指向github Pages 在source文件夹中新建一个CNAME文件(无后缀名),然后用文本编辑器打开,在首行添加你的网站域名,如http://xxxx.com,注意前面没有http://,也没有www. 在域名解析提供商 先添加一个CNAME,主机记录写@,后面记录值写上你的http://xxxx.github.io 再添加一个CNAME,主机记录写www,后面记录值也是http://xxxx.github.io 这样别人用www和不用www都能访问你的网站.也可以使用A记录,对应的记录值位github page的ip 等1分钟左右,刷新浏览器 1234@ A 192.30.252.153@ A 192.30.252.154@ CNAME username.github.iowww CNAME username.github.io.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何让wordpress支持代码缩进和高亮]]></title>
      <url>%2F2016%2F11%2F23%2Fwordpress-%E5%A6%82%E4%BD%95%E8%AE%A9wordpress%E6%94%AF%E6%8C%81%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E5%92%8C%E9%AB%98%E4%BA%AE%2F</url>
      <content type="text"><![CDATA[##如何让wordpress支持代码缩进和高亮? wordpress的默认编辑器不支持代码代码缩进和高亮,需要插件WP Code Highlight支持 插件的下载 下载地址:https://wordpress.org/plugins/wp-code-highlight/ 下载后解压得到wp-code-highlight文件夹，上传至 /wp-content/plugins/ 目录，然后在后台“插件”那里启用。 对插件进行个性化的设置方法:登入后→设置→WP Code Highlight。 写文章时将代码放在&lt;pre&gt;和&lt;/pre&gt;中间即可 NOTE:Html编辑器中已经提供了一个名为WP-Code-Highlight的按钮，方便你插入代码 5.WP Code Highlight代码高亮演示 12345678910/** * Gets whether the TextView includes extra top and bottom padding to make * room for accents that go above the normal ascent and descent. * * @attr ref android.R.styleable#TextView_includeFontPadding * @see #setIncludeFontPadding(boolean) */public boolean getIncludeFontPadding() &#123; return mIncludePad;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F23%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
