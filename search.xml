<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[探究 Android 的事件机制]]></title>
      <url>%2F2016%2F12%2F14%2Fandroid-6-%E6%8E%A2%E7%A9%B6%20Android%20%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[探究 Android 的事件机制一，前言最近着手探究Android 事件机制，说来惭愧，源于看到自己的简历上豁然写着一句熟悉Android事件分发机制，突然发现对于事件机制还停留在事件机制传递时的消耗问题上，对于Android OS中的事件模式没有概念。探究Android OS的事件机制主要从以下几个问题着手: Android中的事件是什么? Android中,一个事件InputEvent是怎么产生的? 监控系统事件的InputManager是如何启动的? 一个应用程序窗口(activity)是如何接收到事件消息的? 在应用层，一个事件消息是如何传递？ …. 带着以上几个问题，我们就可以大体理解了Android 的事件机制。 二，准备工作在理解Android 的事件机制之前，需要对一些准备，即整个事件机制涉及到哪些类和一些类的作用。 2.1 事件机制涉及到哪些类？123456789101112131415161718===Native层./frameworks/base/services/input/InputManager.cpp./frameworks/base/services/input/InputManager.h./frameworks/base/services/input/InputReader.cpp./frameworks/base/services/input/InputReader.h./frameworks/base/services/input/InputDispatcher.cpp./frameworks/base/services/input/InputDispatcher.h./frameworks/base/services/input/EventHub.cpp./frameworks/base/services/input/EventHub.h./frameworks/base/services/input/InputListener.cpp===jni层./frameworks/base/services/jni/com_android_server_input_InputManagerService.cpp===java层./frameworks/base/core/java/android/view/InputEvent.java./frameworks/base/core/java/android/view/KeyEvent.java./frameworks/base/core/java/android/view/MotionEvent.java./frameworks/base/services/java/com/android/server/wm/WindowManagerService.java./frameworks/base/services/java/com/android/server/input/InputManagerService.java 其中还涉及到设备节点文件，主要一下： 123456/dev/input/event0/dev/input/event1/dev/input/event2/dev/input/event3/dev/input/event4/dev/input/event5 与event对应的相关设备信息位于/proc/bus/input/devices，我们可以利用如下命令看一下 1cat /proc/bus/input/devices 也可以通过getevent命令看一下设备节点文件响应事件时的一下输出日志: 12345678910111213shell@mako:/ # cat /proc/bus/input/devices add device 1: /dev/input/event0 name: "pmic8xxx_pwrkey" ####电源按键add device 2: /dev/input/event1 name: "keypad_8064" ####在手机上按音量键会响应add device 3: /dev/input/event4 name: "apq8064-tabla-snd-card Headset Jack" ####?????add device 4: /dev/input/event3 name: "apq8064-tabla-snd-card Button Jack" ####?????add device 5: /dev/input/event5 name: "hs_detect" ####?????add device 6: /dev/input/event2 name: "touch_dev" ####touch之类事件(包括软键盘的触摸) 大体理解一下这些设备文件，每个设备中设备节点文件/dev/input/eventX会有所不同，具体就不深究每个设备文件节点响应什么类型的事件了，如果项目上有需求的话在细细的研究补全吧。 2.2 类作用说明InputManager：统一管理系统的InputEvent事件的管理器InputEvent：事件在java层的描述KeyEvent：键盘事件MotionEvent：屏幕触摸事件InputReader：监控系统事件的发生InputDispatcher：把事件分发给系统当前激活的应用程序窗口处理EventHub：是输入设备的控制中心,它直接与input driver打交道;负责处理输入设备的增减,查询,输入事件的处理并向上层提供getEvents()接口接收事件WindowManagerService：窗口管理系统服务，系统消息的收集与分发等 三，Android中的事件是什么?用户与Android设备交互式时，会产生的各种事件，如用户用遥控器操作机顶盒发生的键盘事件，或者用户触摸Android手机屏幕发生的触摸事件等，我们把这些事件统称为人机交互时的用户输入事件InputEvent。对于InputEvent，Android分为2大类:一种是KeyEvent,即键盘事件,来自Android设备的软件键盘或者外设(遥控器);一种是MotionEvent,即屏幕触摸事件,来自用户触摸屏幕的事件; InputEvent只是一种描述，或者说是java层的一种描述，直接可以理解为用户输入到设备中的事件。 四，Android中中一个事件(InputEvent)是怎么产生的?一个事件的产生肯定需要用户的交互，也就是说，只有当用户触摸屏幕或按下某个按键之类的操作之后系统才能产生一个事件。参考linux输入子系统，我们可以大体理解为: 123456789101112131415161718192021222324252627在用户与系统交互时，Android里面的设备节点文件(/dev/input/eventX)，通过输入子系统设备驱动层和核心层把硬件产生的事件转换为事件数据，然后Android系统中的InputReader就可以读取设备节点文件来获取一个事件。``` 关于linux输入子系统具体可以参考[driver:Linux设备模型之input子系统详解](http://blog.chinaunix.net/uid-23381466-id-3875934.html)。### 五，监控系统事件的InputManager是如何启动的?&gt;TODO这里只大体发一下流程，具体到里面的代码细节和逻辑会在其他博客中说明```java--&gt;SystemServer.main()--&gt;ServerThread.initAndLoop():传说中的init2():开启Android的Framework世界--&gt;通过构造创建InputManagerService--&gt;InputManagerService.nativeInit()--&gt;com_android_server_input_InputManagerService.cpp.nativeInit()--&gt;创建NativeInputManager--&gt;在NativeInputManager构造中创建InputManager--&gt;在InputManager构造中创建InputReader,InputDispatcher,并创建相应的reader和dispatcher线程--&gt;InputManagerService.start()--&gt;InputManagerService.nativeStart(int mPtr);--&gt;com_android_server_input_InputManagerService.cpp.nativeStart(JNIEnv* env, jclass clazz, jint ptr)--&gt;InputManager.start()--&gt;启动InputReaderThread和InputDispatcherThread线程 --&gt;InputDispatcherThread::threadLoop() --&gt;InputDispatcher-&gt;dispatchOnce() --&gt;InputDispatcherThread::threadLoop() --&gt;InputReader-&gt;loopOnce() 六，一个应用程序窗口(activity)是如何接收到键盘消息的? TODO 具体到里面的代码细节和逻辑会在其他博客中说明(后续补上)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究 Android apk 安装过程]]></title>
      <url>%2F2016%2F11%2F30%2Fandroid-5-%E6%8E%A2%E7%A9%B6%20Android%20%20apk%20%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[探究 Android apk 安装过程一，前言在我们在前文探究Android OS 启动流程中，在第八部分我们遗留了app的安装与启动的分析。下面我就我们自身app的安装流程分析一下。 二，apk的安装方式普通用户接触的app安装方式大都是从应用商店一键式安装或者下载app的安装包，然后点击安装，开发人员在调试apk工程中大多会用adb 或 pm命令安装。在以上几种过程中app的安装界面有的是暴露给用户的，有的是隐藏的，我们就是否显示给用户安装界面把安装方式分为有界面安装和无界面安装。 12345有界面安装: 1.从SD卡点击安装包进程安装无界面安装: 1.内置app开机安装 2.adb或pm命令安装 三，Android OS 如何识别文件？今天我们重点分析一下有界面的安装的工程。在探讨安装过程之前，我们要先探讨一下OS是如何识别文件的？OS怎么知道用户点击一个文件该调用什么应用处理点击的文件？ 目前来看，只是根据后缀名，OS通过文件的后缀名，找到对应MIMEType类型。然后在网Intent中设置数据的设置对应的MIMEType，就能通过隐式意图找到相应处理程序。我们看一下OS定义的MIMEType类型，见源码./libcore/luni/src/main/java/libcore/net/MimeUtils.java。我们看一下我们比较熟悉的几个，其他的请自行参考源码 12345678910111213static &#123; .... add("application/zip", "zip"); add("application/vnd.android.package-archive", "apk"); add("video/mp4", "mp4"); add("video/3gpp", "3gpp"); add("text/plain", "txt"); add("image/gif", "gif"); add("image/ico", "ico"); add("image/jpeg", "jpeg"); add("image/jpeg", "jpg"); ....&#125; ok，我们知道了对应MIMEType，调用如下代码就可进程一个.apk的安装了 12345File apkFile;Intent intent = new Intent(Intent.ACTION_VIEW);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setDataAndType(Uri.fromFile(apkFile), "application/vnd.android.package-archive");context.startActivity(intent); AMS在处理此隐式意图时，最终其找到com/android/packageinstaller/PackageInstallerActivity.java。我么看一下对应则个Activity的清单文件的注册: 1234567891011121314151617&lt;activity android:name=".PackageInstallerActivity" android:configChanges="orientation|keyboardHidden|screenSize" android:excludeFromRecents="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;action android:name="android.intent.action.INSTALL_PACKAGE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="file"/&gt; &lt;data android:mimeType="application/vnd.android.package-archive"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.INSTALL_PACKAGE"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="file"/&gt; &lt;data android:scheme="package"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 三，apk 的安装界面我们先看一下PackageInstallerActivity的onCreate()方法。 1234567891011121314151617181920212223242526272829303132@Overrideprotected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); // get intent information final Intent intent = getIntent(); //NOTE(ljs):apk文件的绝对路径例如file:///storage/sdcard/mytest.apk mPackageURI = intent.getData(); //FIXME(ljs):这2个URl代表啥意思? mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); mPm = getPackageManager();//ApplicationPackageManager //NOTE(ljs):判断是否从未知来源下载的app boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); //NOTE(ljs):安装流分析器 mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(isInstallingUnknownAppsAllowed()); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); .... //NOTE(ljs):set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); .... //NOTE(ljs): initiateInstall();&#125; 1234private void initiateInstall() &#123; .... startInstallConfirm();&#125; 12345678910private void startInstallConfirm() &#123; .... mInstallConfirm.setVisibility(View.VISIBLE); mOk = (Button) findViewById(R.id.ok_button); mCancel = (Button) findViewById(R.id.cancel_button); //NOTE(ljs):ok和cancle的监听事件 mOk.setOnClickListener(this); mCancel.setOnClickListener(this); ...&#125; 大体流程如下： 从Intent中获取要安装apk或file的路径信息，判断apk的安装方式 初始化PackageInstallerActivity的UI，给界面的上确认按钮和取消安装事件监听 我们接下来看一下点击确认按钮发生了什么？ 四，apk 的安装过程。我们从源码中发现，当用户点击ok后，启动了InstallAppProgress，并将安装apk的信息传递给它，接着在其initView()方法中通过Binder启动服务PackageManagerService，将真正的安转过程交给服务来做. 12345public void initView() &#123; .... pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags, installerPackageName, verificationParams, null);&#125; 然后我们看一下ApplicationPackageManager的pm.installPackageWithVerificationAndEncryption()方法 1234567891011@Override public void installPackageWithVerificationAndEncryption(Uri packageURI, IPackageInstallObserver observer, int flags, String installerPackageName, VerificationParams verificationParams, ContainerEncryptionParams encryptionParams) &#123; //NOTE(ljs):apk的安装从PackageManager的installApk方法开始, //NOTE(ljs):由于PackageManager所对应的binder服务为PackageManagerService //NOTE(ljs):所以,真正的安装过程都在PackageManagerService中完成 try &#123; mPM.installPackageWithVerificationAndEncryption(packageURI, observer, flags, installerPackageName, verificationParams, encryptionParams); &#125; catch (RemoteException e) &#123; // Should never happen! &#125; &#125; 下面我么看一下在PackageManagerService服务中究竟安装包是怎么被安装到OS上的？ 4.1 什么是PackageManagerService？PackageManagerService主要负责管理系统的Package,包括APK的安装/卸载/信息的查询等等，在SystemServer.initAndLoop()中启动。PackageManagerService的启动非常复杂，涉及到Setting对象、属性系统、Installer系统、PackageHandler、系统权限、、AndroidManifest.xml、Resouce,、FileObserver已经APK的安装包的扫面等等这里我们就不过多描述了，我们只要知道这个 服务管理着apk的安装与卸载就可以了。我们先大体看一下PackageManagerService的main()方法: 12345public static final IPackageManager main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService("package", m); return m;&#125; 创建了一个PackageManagerService服务实例,然后把这个服务添加到ServiceManager中去，主要实现逻辑在PackageManagerService的构造中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; .... //NOTE(ljs):1.Setting对象的创建和初始化 //1.1构造Settings对象 mSettings = new Settings(context); .... synchronized (mInstallLock) &#123; // writer synchronized (mPackages) &#123; //NOTE(ljs):3.启动PackageHandler,处理Apk安装请求 // 可以看出HandlerThread和PackageHandler分别代表系统通信模型中的Looper线程和Handler处理器, // 其中PackageHandler是PMS的内部类,它的handleMessage()的实现实际调用了doHandleMessage() // mHandlerThread.start()--&gt;Looper.loop()--&gt;PackageHandler.handleMessage() // 这里的作用就是启动mHandlerThread,不断从消息队列中取出来消息,交给PackageHandler处理 mHandlerThread.start(); mHandler = new PackageHandler(mHandlerThread.getLooper()); Watchdog.getInstance().addThread(mHandler, mHandlerThread.getName(), WATCHDOG_TIMEOUT); //NOTE(ljs):4.创建data目录并初始化UserManager File dataDir = Environment.getDataDirectory(); mAppDataDir = new File(dataDir, "data"); mAppInstallDir = new File(dataDir, "app"); mAppLibInstallDir = new File(dataDir, "app-lib"); mAsecInternalPath = new File(dataDir, "app-asec").getPath(); mUserAppDataDir = new File(dataDir, "user"); mDrmAppPrivateInstallDir = new File(dataDir, "app-private"); //初始化UserManager sUserManager = new UserManagerService(context, this, mInstallLock, mPackages); //NOTE(ljs):5.解析系统permission和feature信息 readPermissions(); .... //NOTE(ljs):7.启动FileObserver监控Apk文件的目 // Find base frameworks (resource packages without code). // 监控 /system/framework/目录 mFrameworkInstallObserver = new AppDirObserver(frameworkDir.getPath(), OBSERVER_EVENTS, true, false); mFrameworkInstallObserver.startWatching(); //NOTE(ljs):8.调用scanDirLI()扫描并安装apk文件 scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanMode | SCAN_NO_DEX, 0); mRequiredVerifierPackage = getRequiredVerifierLPr(); &#125; // synchronized (mPackages) &#125; // synchronized (mInstallLock)&#125; 总结一下如下： 创建并穿实话Settings对象 获取系统默认配置 启动PackageHandler,处理Apk安装请求 创建data目录并初始化UserManager 解析系统permission和feature信息 dexopt优化判断 启动FileObserver监控Apk文件的目录 调用scanDirLI()扫描并安装apk包 调用writeLPr()更新packages.xml/packages-backup.xml等文件 4.2 apk 的复制过程我们跟进一下 1234567public void installPackageWithVerificationAndEncryption(Uri packageURI, IPackageInstallObserver observer, int flags, String installerPackageName, VerificationParams verificationParams, ContainerEncryptionParams encryptionParams) &#123; .... //NOTE(ljs):构造一个消息,类型为INIT_COPY,其obj为一个InstallParams final Message msg = mHandler.obtainMessage(INIT_COPY); msg.obj = new InstallParams(packageURI, observer, filteredFlags, installerPackageName, verificationParams, encryptionParams, user); mHandler.sendMessage(msg);&#125; 该方法核心就是最后往PackageHandler发送了一个INIT_COPY消息，来完成apk相关数据的复制过程。 我们通过代码跟踪可以发现，真正实现apk拷贝的方法是InstallParams的handleStartCopy(),该方法利用PackageInfo获取该apk的安装路径，也就是apk到底是安装在内部存储还是外部存储。然后把带安装的apk复制到/data/app目录中，我们可以看一下这个目录里面有我们要安装的apk，一般会出现如packagename-1.apk的文件。 关于InstallParams的handleStartCopy()里面的具体实现，由于涉及到了MediaContainerService(即MCS服务)，我们这里不展开讲了，只需明白这是个copy过程就可以了。 4.3 apk 解析过程由于我们的PMS在构造中创建了AppDirObserver，一直在监视着文件目录结构的变化。在安装包被复制到/data/app后，AppDirObserver监听有文件添加动作，会会用到相应的方法处理事件。我们从源码也能看到 AppDirObserver extends FileObserver，AppDirObserver是个观察者。 下面我们看一下它处理事件的方法 12345678910111213141516public void onEvent(int event, String path) &#123; .... p = scanPackageLI(fullPath, flags, SCAN_MONITOR | SCAN_NO_PATHS | SCAN_UPDATE_TIME, System.currentTimeMillis(), UserHandle.ALL); ... if (removedPackage != null) &#123; Bundle extras = new Bundle(1); extras.putInt(Intent.EXTRA_UID, removedAppId); extras.putBoolean(Intent.EXTRA_DATA_REMOVED, false); sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED, removedPackage, extras, null, null, removedUsers); &#125; if (addedPackage != null) &#123; Bundle extras = new Bundle(1); extras.putInt(Intent.EXTRA_UID, addedAppId); sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, addedPackage, extras, null, null, addedUsers); &#125;&#125; 方法主要是扫描apk安装包，解析apk响应的数据，完成后发送了apk安装和删除广播。 关于scanPackageLI()方法，主要完成了如下工作: 如果包名是android，则会做一些特殊处理，这个包名为android的应用是系统内部应用的，其他应用的包名如果叫android则安装会有问题，大家可以试一下 解析常见的use-feature、shared-userId、use-library标签并保存到成员变量中 进行签名验证，对应的方法是verifySignaturesLP，验证失败则应用无法安装 创建应用程序目录/data/data/包名，同时将apk中提取出dex文件并保存到/data/dalvik-cache，把apk当做zip解压就能得到dex文件 解析AndroidManifest.xml文件，提取出所需信息，包括具有intent-filter的四大组件信息（Activity、Service、BroadcastReceiver、ContentProvider）和声明的系统权限等. 下面我们看一下解析AndroidManifest.xml的过程，对应的代码见PackageParser的parsePackage()方法 1234567891011121314151617181920private Package parsePackage(Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; .... //NOTE(ljs):解析VersionCode 、VersionName、sharedUserId、installLocation、 TypedArray sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifest); pkg.mVersionCode = sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode, 0); pkg.mVersionName = sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifest_versionName, 0); //NOTE(ljs):开始解析xml文件的子标签 int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; .... //NOTE(ljs):解析application 标签,四大组件在这里注册配置 if (tagName.equals("application")) &#123; ... &#125; &#125; return pkg;&#125; 可以看到利用Pull解析了AndroidManifest.xml各个节点。 apk安装完成时，系统会将apk对应的package信息写入系统的注册表packages.list和packages.xml中，我们可以看一下; 123#/data/system/packages.list...com.voole.epg 10038 1 /data/data/com.voole.epg default 3003,1028,1015 123456789101112131415161718192021222324&lt;package name="com.voole.epg" codePath="/data/app/com.voole.epg-1.apk" nativeLibraryPath="/data/app-lib/com.voole.epg-1" flags="1621574" ft="531a2b8" it="531ae57" ut="531ae57" version="29301" userId="10038"&gt; &lt;sigs count="1"&gt; &lt;cert index="0" key="3082030d308201f5a0...." /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;item name="android.permission.GET_TASKS" /&gt; &lt;item name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;item name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;item name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;item name="android.permission.RESTART_PACKAGES" /&gt; &lt;item name="android.permission.KILL_BACKGROUND_PROCESSES" /&gt; &lt;item name="android.permission.READ_PHONE_STATE" /&gt; &lt;item name="android.permission.SYSTEM_ALERT_WINDOW" /&gt; &lt;item name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt; &lt;item name="android.permission.INTERNET" /&gt; &lt;item name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;item name="android.permission.VIBRATE" /&gt; &lt;item name="android.permission.FLASHLIGHT" /&gt; &lt;item name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;item name="android.permission.WAKE_LOCK" /&gt; &lt;/perms&gt; &lt;signing-keyset identifier="1" /&gt; &lt;/package&gt; 五，再看apk 的安装过程。回个我们再看真个apk的安装过程，主要分为如下几部 拷贝apk文件到指定目录 解压apk，拷贝文件，创建应用的数据目录 解析apk的AndroidManifinest.xml文件 向Launcher应用申请添加创建快捷方式 我们对比一下我们平时在PC端安装一个.exe文件的过程： 解压exe文件到系统的临时目录 拷贝核心文件到指定的程序目录 写注册表 添加到开始菜单以及桌面快捷方式 是不是很相似。这样一对比是不是不用再纠结源码中各种过程的细节问题，整个安装过程一目了然了。 关于apk的卸载问题，我们对应一下PC端一个应用的卸载，是不是可以可以知道，整个过程就是删除文件，清理注册表的过程，和安装过程是逆向过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究 Android 属性服务]]></title>
      <url>%2F2016%2F11%2F28%2Fandroid-4-%E6%8E%A2%E7%A9%B6%20Android%20%E5%B1%9E%E6%80%A7%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[探究 Android 属性服务一，前言在系统初始化时，Android会分配一个共享内存区来存储一些系统属性，主要用来记录系统相关设置、状态或者进程之间交互信息。一部分系统属性是从本地文件加载到内存中的，一部分是在内存临时创建的。系统属性对于整个OS是可见的，每个进程都可以利用属性服务对系统属性进程get或set操作。下面我们看看整个属性机制是怎么运作的？ 二，属性系服务流程图涉及到的类 12345./frameworks/base/core/jni/android_os_SystemProperties.cpp./system/core/init/init.c./system/core/init/property_service.c./bionic/libc/include/sys/_system_properties.h./bionic/libc/bionic/system_properties.c 流程图： 三，属性系服务3.1 属性系服务的初始化我们在前文探究Android OS 启动流程中得知，在init进程中会开启Android 的属性服务: 123456789int main(int argc, char **argv)&#123; .... //NOTE(ljs):初始化属性服务 property_init(); .... //NOTE(ljs):启动属性服务 queue_builtin_action(property_service_init_action, "property_service_init"); ....&#125; 我们进一步看一下Property的初始化，参照 property_service.c 。 1234void property_init(void)&#123; init_property_area();&#125; 123456789101112131415161718static int init_property_area(void)&#123; //NOTE(ljs):判断是否已经初始化过了 if (property_area_inited) return -1; //NOTE(ljs):初始化区域用于存储属性--打开/dev/__properties__设备,然后mmap一块大小为(128 * 1024)的内存出来 if(__system_property_area_init()) return -1; //NOTE(ljs):以只读的方式打开/dev/__properties__文件 if(init_workspace(&amp;pa_workspace, 0)) return -1; fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC); //NOTE(ljs):初始化完毕 property_area_inited = 1; return 0;&#125; 关于初始化内存，我们看一下__system_property_area_init() 1234int __system_property_area_init()&#123; return map_prop_area_rw();&#125; 继续追踪， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static int map_prop_area_rw()&#123; prop_area *pa; int fd; int ret; /* dev is a tmpfs that we can use to carve a shared workspace * out of, so let's do that... */ //NOTE(ljs):文件property_filename被打开,并以读写,可共享的方式映射到了内存 fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC | O_EXCL, 0444); if (fd &lt; 0) &#123; if (errno == EACCES) &#123; /* for consistency with the case where the process has already * mapped the page in and segfaults when trying to write to it */ abort(); &#125; return -1; &#125; ret = fcntl(fd, F_SETFD, FD_CLOEXEC); if (ret &lt; 0) goto out; //NOTE(ljs):改变文件大小为PA_SZIE = 128 * 1024 if (ftruncate(fd, PA_SIZE) &lt; 0) goto out; pa_size = PA_SIZE; pa_data_size = pa_size - sizeof(prop_area); compat_mode = false; //NOTE(ljs):在init进程中将/dev/__properties__文件映射成一块可读可写的内存 //NOTE(ljs):注意,我们在后面会看到,在其他客户端进程都是以只读的形式访问pa的,如果客户端要修改或者新增属性,那么需要进程间通信,最后都是由init进程来完成的 pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(pa == MAP_FAILED) goto out; memset(pa, 0, pa_size); pa-&gt;magic = PROP_AREA_MAGIC; pa-&gt;version = PROP_AREA_VERSION; /* reserve root node */ pa-&gt;bytes_used = sizeof(prop_bt); /* plug into the lib property services */ //NOTE(ljs):最后将pa复制给全局变量__system_property_area__ __system_property_area__ = pa; close(fd); return 0;out: close(fd); return -1;&#125; 3.2 启动属性系服务在init的main()函数中，往待执行队列添加名为 property_service_init_action 的action，对应的函数如下: 1queue_builtin_action(property_service_init_action, "property_service_init"); 12345static int property_service_init_action(int nargs, char **args)&#123; start_property_service(); return 0;&#125; 下面我们看一下属性服务的启动过程： 12345678910111213141516171819202122void start_property_service(void)&#123; int fd; //NOTE(ljs):装载不同的属性文件 //对应配置文件为'/system/build.prop' load_properties_from_file(PROP_PATH_SYSTEM_BUILD); //对应配置文件为'/system/default.prop' load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT); //---/data/local.prop load_override_properties(); load_persistent_properties(); //NOTE(ljs):创建socket服务 fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0); if(fd &lt; 0) return; fcntl(fd, F_SETFD, FD_CLOEXEC); fcntl(fd, F_SETFL, O_NONBLOCK); //NOTE(ljs):开始服务监听 listen(fd, 8); property_set_fd = fd;&#125; 第一步：往内存中装载不同的属性文件，我们去./bionic/libc/include/sys/_system_properties.h中看一下宏定义 1234#define PROP_PATH_RAMDISK_DEFAULT "/default.prop"#define PROP_PATH_SYSTEM_BUILD "/system/build.prop"#define PROP_PATH_SYSTEM_DEFAULT "/system/default.prop"#define PROP_PATH_LOCAL_OVERRIDE "/data/local.prop" 其中配置文件/system/build.prop是在android 源码中的:build/tools/buildinfo.sh文件中生成的关于Android属性之build.prop生成过程 第二步： 创建socket服务第三步： 开始服务监听 四，属性的读写流程应用层，我们可以通过SystemProperties.set()/SystemProperties.get()来操作属性值，但是android.os.SystemProperties这个类是{@ hide}的，我们可以通过反射的方法调用其先关API，具体的怎么使用这里就不细讲了，我们只讲一下流程。 当我们调用SystemProperties.set()时，通过JNI最终映射到properties.c的__system_property_set()函数 1234567891011121314151617181920212223int __system_property_set(const char *key, const char *value)&#123; int err; prop_msg msg; if(key == 0) return -1; if(value == 0) value = ""; if(strlen(key) &gt;= PROP_NAME_MAX) return -1; if(strlen(value) &gt;= PROP_VALUE_MAX) return -1; memset(&amp;msg, 0, sizeof msg); msg.cmd = PROP_MSG_SETPROP; strlcpy(msg.name, key, sizeof msg.name); strlcpy(msg.value, value, sizeof msg.value); //NOTE(ljs):通过socket向property_service发送消息 err = send_prop_msg(&amp;msg); if(err &lt; 0) &#123; return err; &#125; return 0;&#125; 然后我们看一下send_prop_msg()函数 12345678static int send_prop_msg(prop_msg *msg)&#123; .... //NOTE(ljs):sokcet 通信 /dev/socket/property_service s = socket(AF_LOCAL, SOCK_STREAM, 0); .... return result;&#125; 下面我们看看属性服务Property Service 收到消息后做了什么 123456789101112131415161718192021222324252627void handle_property_set_fd()&#123; .... //NOTE(ljs):等待建立通信 if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) &#123; return; &#125; .... //NOTE(ljs):获取套接字相关信息 uid gid if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) &#123; close(s); ERROR("Unable to receive socket options\n"); return; &#125; //NOTE(ljs):recv()函数,接收属性设置请求消息 r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), 0)); .... //NOTE(ljs):处理消息 switch(msg.cmd) &#123; case PROP_MSG_SETPROP: .... default: close(s); break; &#125;&#125; 下面我们看一下SystemProperties.get()过程。 12345int __system_property_get(const char *name, char *value)&#123; const prop_info *pi = __system_property_find(name); return __system_property_read(pi, 0, value);&#125; TODO 目前大体理解一下Android 的属性服务，暂时分析到这里。 参考文档:http://www.cnblogs.com/bastard/archive/2012/10/11/2720314.htmlhttp://blog.chinaunix.net/uid-20459533-id-3168973.htmlhttp://www.cnblogs.com/simonshi/archive/2010/04/08/1707516.htmlhttp://blog.csdn.net/zhangchiytu/article/details/7539101]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究 Android 开机画面]]></title>
      <url>%2F2016%2F11%2F26%2Fandroid-3-%E6%8E%A2%E7%A9%B6%20Android%20%E5%BC%80%E6%9C%BA%E7%94%BB%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[探究 Android 开机画面一，前言我们在前文探究Android OS 启动流程中曾有遗留问题 我们依次在屏幕上看到的各种logo、动画是什么?那个阶段现实的？ 下面我们就探究一下各种logo及动画出现的时机和展现原理。 二，关于开机画面由于Android是基于Linux 2.6版本的，所以在整个Android OS启动过程中，理论上会涉及到Linux内核的启动画面与静态画面，然后在原生真机Nexus 4上我们并没有看到传说中的小企鹅画面。由于技术限制每层探究到Linux Kernel层面，所以对于Linux内核层面的动画我们只是简单地说一下流程，方便理解以及过渡到我们Android层面的开机动画。我们先用一张图说一下开机画面的流程: 三，关于开机画面第一层动画 //TODO 有序研究到这层会补充完成 四，关于开机画面第二层动画 //TODO 有序研究到这层会补充完成 五，关于开机画面第三层动画下面我们来说说开机画面第三层动画，在源码涉及到的类有如下: 12./system/core/init/init.h./system/core/init/init.c 从上面涉及到的类我们就明白，这个画面应该是Init进程启动过程中出现的静态画面。我们记得在ini.c的main()函数中利用函数queue_builtin_action()，向init进程中的一个待执行队列(触发器为early-init)增加了一个名称等于”console_init”的action，这个action对应的执行函数为console_init_action(),它就是用来显示android层第二个开机画面的。我们先看一下 123456789101112131415int main(int argc, char **argv)&#123; .... init_parse_config_file("/init.rc"); .... //NOTE(ljs):执行rc文件中触发器为 on early-init的语句 action_for_each_trigger("early-init", action_add_queue_tail); .... //NOTE(ljs):向init进程中的一个待执行action队列增加了一个名称等于"console_init"的action //NOTE(ljs):这个action对应的执行函数为console_init_action,它就是用来显示android层第二个开机画面的 queue_builtin_action(console_init_action, "console_init"); ... //NOTE(ljs):执行rc文件中触发器为 on init的语句 action_for_each_trigger("init", action_add_queue_tail);&#125; 下面我们看一下action的执行函数console_init_action() 123456789101112131415161718192021222324252627static int console_init_action(int nargs, char **args)&#123; .... //NOTE(ljs):加载文件/initlogo.rle,若调用失败,将会显示文字的"ANDROID"logo if( load_565rle_image(INIT_IMAGE_FILE) ) &#123; fd = open("/dev/tty0", O_WRONLY); if (fd &gt;= 0) &#123; const char *msg; msg = "\n" "\n" "\n" "\n" "\n" "\n" "\n" // console is 40 cols x 30 lines "\n" "\n" "\n" "\n" "\n" " A N D R O I D "; write(fd, msg, strlen(msg)); close(fd); &#125; &#125; return 0;&#125; 关于宏命令INIT_IMAGE_FILE定义在: ./system/core/init/init.h 1#define INIT_IMAGE_FILE "/initlogo.rle" 也就是说Android层面的第二个开机画面的内容是由文件/initlogo.rle来指定的。如果文件/initlogo.rle不存在，或者在显示它的过程中出现异常，那么函数load_565rle_image()的返回值就会等于-1，这时候函数console_init_action()就以文本的方式来显示第二个开机画面，即向编号为0的控制台（/dev/tty0）输出“ANDROID”这7个字符。 NOTE/TODO:很不幸的是，依然没有看到这个画面（Nexus 4上/v4.4.2）. 六，关于开机画面第四层动画6.1 开机画面第四层动画的流程这层的画面，我相信很多人很熟悉了，是由bootanimation服务通过OpenGL来渲染画面。涉及到的主要源码文件如下: 123./frameworks/base/cmds/bootanimation/BootAnimation.cpp./frameworks/base/cmds/bootanimation/bootanimation_main.cpp./frameworks/base/cmds/bootanimation/BootAnimation.h 我们知道在Android OS启动的时候会启动SurfaceFlinger服务，关于SurfaceFlinger服务，请阅读罗升阳老师的Android系统Surface机制的SurfaceFlinger服务的启动过程分析，在SurfaceFlinger启动后，在SurfaceFlinger::init()函数中 1234567void SurfaceFlinger::init() &#123; ... // start boot animation //NOTE(ljs):SurfaceFlinger::init() –&gt; startBootAnim()-&gt;property_set("ctl.start", "bootanim"); startBootAnim();&#125; 看一下startBootAnim()函数 12345void SurfaceFlinger::startBootAnim() &#123; // start boot animation property_set("service.bootanim.exit", "0"); property_set("ctl.start", "bootanim");&#125; 我们看懂通过利用属性服务来启动开机动画服务bootanim，属性”ctl.start”和” ctl.stop”是用来启动和停止服务的. bootanim服务定义在init.rc中: 123456service bootanim /system/bin/bootanimation class main user graphics group graphics disabled oneshot 启动bootanimation进程，该进程的源码对应bootanimation_main.cpp，我们看一下主要代码: 123456789int main(int argc, char** argv)&#123; .... // create the boot animation object sp&lt;BootAnimation&gt; boot = new BootAnimation(); .... return 0;&#125; 然后我们看一下BootAnimation的构造 123456//NOTE(lsj):在构造函数中初始化mShutdown = false;表示默认是开机标志BootAnimation::BootAnimation() : Thread(false)&#123; //TODO(ljs):???什么鬼？以后研究 mSession = new SurfaceComposerClient();&#125; 然后我们在readyToRun()函数中看到了对于开机动画问题的判断 12#define USER_BOOTANIMATION_FILE "/data/local/bootanimation.zip"#define SYSTEM_BOOTANIMATION_FILE "/system/media/bootanimation.zip" 1234567891011121314151617181920status_t BootAnimation::readyToRun() &#123; .... //是否显示开机动画 mAndroidAnimation = true; // If the device has encryption turned on or is in process // of being encrypted we show the encrypted boot animation. char decrypt[PROPERTY_VALUE_MAX]; property_get("vold.decrypt", decrypt, ""); bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp("trigger_restart_min_framework", decrypt); if ((encryptedAnimation &amp;&amp; (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp; (mZip.open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE) == NO_ERROR))||...) &#123; mAndroidAnimation = false; &#125; return NO_ERROR;&#125; 主要是通过判断文件是否存在等逻辑来决定是否显示动画。真正的开始阶段如下: 123456789101112131415bool BootAnimation::threadLoop()&#123; bool r; if (mAndroidAnimation) &#123; //NOTE(ljs):执行android字体闪动的图片 r = android(); &#125; else &#123; //NOTE(ljs):执行bootanimation.zip中提供的动画图片 r = movie(); &#125; .... return r;&#125; 如果对bootanimation.zip的种种逻辑判断，得出结论是不播放动画时，就展示Android字体闪动的图片，如果可以播放动画，就播放bootanimation.zip提供的动画。 6.2 关于Android字体闪动的图片我们先看一下函数实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566bool BootAnimation::android()&#123; ALOGD("BootAnimation::android()"); //NOTE(ljs):/frameworks/base/core/res/assets/images/android-logo-mask.png //NOTE(ljs):/frameworks/base/core/res/assets/images/android-logo-shine.png initTexture(&amp;mAndroid[0], mAssets, "images/android-logo-mask.png"); initTexture(&amp;mAndroid[1], mAssets, "images/android-logo-shine.png"); // clear screen glShadeModel(GL_FLAT); glDisable(GL_DITHER); glDisable(GL_SCISSOR_TEST); glClearColor(0,0,0,1); glClear(GL_COLOR_BUFFER_BIT); eglSwapBuffers(mDisplay, mSurface); glEnable(GL_TEXTURE_2D); glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); const GLint xc = (mWidth - mAndroid[0].w) / 2; const GLint yc = (mHeight - mAndroid[0].h) / 2; const Rect updateRect(xc, yc, xc + mAndroid[0].w, yc + mAndroid[0].h); glScissor(updateRect.left, mHeight - updateRect.bottom, updateRect.width(), updateRect.height()); // Blend state glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); const nsecs_t startTime = systemTime(); do &#123; nsecs_t now = systemTime(); double time = now - startTime; float t = 4.0f * float(time / us2ns(16667)) / mAndroid[1].w; GLint offset = (1 - (t - floorf(t))) * mAndroid[1].w; GLint x = xc - offset; glDisable(GL_SCISSOR_TEST); glClear(GL_COLOR_BUFFER_BIT); glEnable(GL_SCISSOR_TEST); glDisable(GL_BLEND); glBindTexture(GL_TEXTURE_2D, mAndroid[1].name); glDrawTexiOES(x, yc, 0, mAndroid[1].w, mAndroid[1].h); glDrawTexiOES(x + mAndroid[1].w, yc, 0, mAndroid[1].w, mAndroid[1].h); glEnable(GL_BLEND); glBindTexture(GL_TEXTURE_2D, mAndroid[0].name); glDrawTexiOES(xc, yc, 0, mAndroid[0].w, mAndroid[0].h); EGLBoolean res = eglSwapBuffers(mDisplay, mSurface); if (res == EGL_FALSE) break; // 12fps: don't animate too fast to preserve CPU const nsecs_t sleepTime = 83333 - ns2us(systemTime() - now); if (sleepTime &gt; 0) usleep(sleepTime); checkExit(); &#125; while (!exitPending()); glDeleteTextures(1, &amp;mAndroid[0].name); glDeleteTextures(1, &amp;mAndroid[1].name); return false;&#125; 利用OpenGL把android-logo-mask.png和android-logo-shine.png展示。这两者图片具体位置: 12./frameworks/base/core/res/assets/images/android-logo-mask.png./frameworks/base/core/res/assets/images/android-logo-shine.png 我们看一下图片 是不是现在明白了什么… TODO OpenGL是如何把这2张图片呈现出来的？？？？？？？待研究 6.3 关于Android的bootanimation.zip动画我们先看一下具体函数实现: 12345bool BootAnimation::movie()&#123; .... //NOTE(ljs):OpenGL相关不作分析...&#125; 我们看一下到底bootanimation.zip文件是个什么样的文件。我已将把miui和优朋普乐的开机动画文件传至github。github-bootanimation 我们解压miui的会看到如下文件 12345678|--bootanimation |--part0 |-01.png |-02.png |-03.png |-04.png |-05.png |--desc.txt 当看到01-05.png的时候，我想大家就明白了，原来我们看到的动画是这5张图片的帧动画。而对于desc.txt 文件我们看一下内容: 121080 1920 5p 0 5 part0 对于这个描述文件我组一下说明: 121080 1920 5 ----这里的1080代表图片的像素（大小）宽度，1920代表图片的像素（大小）高度，5代表帧数，也就是图片一共多少张p 1 0 part0 ---这里的p代表标志符，1代表循环次数为1次，0代表阶段间隔时间为0,part0代表对应的文件夹名 对应voole的bootanimation.zip文件解压如下: 12345678910|--bootanimation |--part0 |-01.png |--part1 |-01.png |-02.png |-03.png |-04.png |-05.png |--desc.txt desc.txt描述如下: 1231280 720 3p 1 0 part0p 5 0 part1 如此我们看到这个bootanimation.zip帧动画的实现的灵活性。 七，开机画面的最后通过上面我们基本了解了整个开机画面的显示流程和实现细节(其实还有大量没研究…)。最后通过探究开机动画的内部实现，发现Android 涉及的知识面太庞大。努力学习…. TODO: 既然开机可以播放帧动画，能不是播放音频视频类呢？目前 音频已成功，视频未成功….由于不熟悉Media Server整体的架构，后期研究后不上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究 init.rc 脚本]]></title>
      <url>%2F2016%2F11%2F26%2Fandroid-2-%E6%8E%A2%E7%A9%B6%20init.rc%20%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[探究 init.rc 脚本一，前言我们在前文探究Android OS 启动流程中，曾说过，init进程解析init.rc脚本然后启动各种service，比如zygote、servicemanager等.下面我们来一探究竟。关于init.rc 源码在./system/core/rootdir/init.rc.其说明文件google也给出来了就在源码里./system/init/readme.txt，如果你英文比较好，基本可以略过这篇文章了。 二，关于init.rcinit.rc文件基本组成单位是section(段落)，section分为三种类型，分别用on,service,import关键字表示. 2.1 import 类型 主要作用: 表示引入另外一个xx.rc文件 语法: 1234import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.trace.rc 2.2 on 类型 主要作用: 表示一系列命令的组合(也就是Action类型): 语法: 1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; 2.3 service 类型 主要作用: 表示一个可执行程序 语法:表示一个可执行程序 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 三，关于init.rc 语句语法我们上面说了init.rc文件的基本组成单位是section，而上述的3中section只要有如下几种语句组成 3.1:Action(动作):表示了一组命令(commands)组成. Action包含一个trigger(触发器)，决定了何时执行这个动作; 当触发器的条件满足时,这个动作会被加入到已被执行的队列尾; 如果此动作在队列中已经存在,那么它将不会执行. 一个Action所包含的命令将被依次执行;动作的语法如下所示: 1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; 3.2:Commands:命令Commands 详见如下: 命令 描述 chmod &lt;octal-mode&gt; &lt;path&gt; 改变指定文件的读取权限 chown &lt;owner&gt; &lt;group&gt; &lt;path&gt; 改变指定文件的拥有都和组名的属性 chroot &lt;directory&gt; 改变进行的根目录 class_start &lt;serviceclass&gt; 启动指定类属的所有服务，如果服务已经启动，则不再重复启动 class_stop &lt;serviceclass&gt; 停止指定类属的所胡服务 domainname &lt;name&gt; 设置域名 export &lt;name&gt; &lt;value&gt; 设置全局环境参数，此参数被设置后对所有进程都有效 exec &lt;path&gt; [ &lt;argument&gt; ]* 执行指定路径下的程序，并传递参数 hostname &lt;name&gt; 设置主机名 ifup &lt;interface&gt; 使指定的网络接口”上线”，相当激活指定的网络接口 import &lt;filename&gt; 导入一个额外的init配置文件 insmod &lt;path&gt; 安装模块到指定路径 mkdir &lt;path&gt; [mode] [owner] [group] 用指定参数创建一个目录，在默认情况下，创建的目录读取权限为755，用户名为root，组名为root mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;mountoption&gt; ]* 类似于linux的mount指令 start &lt;service&gt; 如果指定的服务未启动，则启动它 stop &lt;service&gt; 如果指定的服务当前正在运行，则停止它 setprop &lt;name&gt; &lt;value&gt; 设置属性及对应的值 trigger &lt;event&gt; 触发器 write &lt;path&gt; &lt;string&gt; [ &lt;string&gt; ]* 往指定的文件写字符串 3.3:Services:服务是指那些需要在系统初始化时就启动或退出时自动重启的程序。它的语法结构如下所示: 1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... 3.4:OptionsOptions:用来修改服务的;它们影响如何及何时运行这个服务 选项 描述 critical 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。 disabled 服务不会自动运行，必须显式地通过服务器来启动。 setenv &lt;name&gt; &lt;value&gt; 设置环境变量 socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; ] ] 在/dev/socket/下创建一个unix domain的socket，并传递创建的文件描述符fd给服务进程.其中type必须为dgram或stream,seqpacket。用户名和组名默认为0 user &lt;username&gt; 在执行此服务之前先切换用户名。当前默认为root. oneshot 当此服务退出时不会自动重启. class &lt;name&gt; 给服务指定一个类属。这样方便操作多个服务同时启动或停止。默认情况下为default。 onrestart 当服务重启时执行一条指令 3.5:triggertrigger:触发器,或者叫做触发条件 触发器 描述 boot 当init程序执行，并载入/init.conf文件时触发. &lt;name&gt;=&lt;value&gt; 当属性名对应的值设置为指定值时触发. device-added-&lt;path&gt; 当添加设备时触发. device-removed-&lt;path&gt; 当设备移除时触发. service-exited-&lt;name&gt; 当指定的服务退出时触发. 四，语法的最后12341. 在init.rc文件中一条语句通常是占据一行;2. 单词之间是通过空格符来相隔的;3. 如果需要在单词内使用空格,那么得使用转义字符"\",如果在一行的末尾有一个反斜杠,那么是换行折叠符号,应该和下一行合并成一起来处理,这样做主要是为了避免一行的字符太长,与C语言中的含义是一致的;4. 注释是以#号开头;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解SSH协议]]></title>
      <url>%2F2016%2F11%2F25%2Fserver-%E7%90%86%E8%A7%A3SSH%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[理解SSH协议一，什么是SSH协议？SSH，全称Secure SHell protocol，即安全外壳协议，可以在不安全的网络环境里提供安全远程登录及其他安全网络服务的协议。 二，秘钥说明 公钥和私钥的关系类似解密。 在登录和验证时，都会同时用到这两个密钥。 公钥位于服务器上(远程位置)。 私钥位于本地计算机/服务器上。 当登录服务器时，两者将进行配对。 如果它们配对成功，您将可以登录到服务器上 用公钥认证是密码认证的一种替换方式。由于必须持有私钥才能认证，所有要想强行破解几乎是不可能的 三，SSH的工作原理 12345678910111213141516171819202122232425261. server启动sshd服务，生成公钥+私钥2. 客户端主动发送请求命令如下:&gt; $ ssh username@ip3. server响应请求，将公钥（????明文????）发给clientclient收到server的公钥后做了如下工作&gt;客户端记录并比对服务器的公钥数据及随机计算自己的公私钥 :&gt;若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的 ~/.ssh/known_hosts 。&gt;若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。&gt;若接受此公钥， 则开始计算客户端自己的公钥+私钥.4. clent将自己的公钥回传到server此时:&gt;server :具有自己的私钥和client的公钥;&gt;client :具有自己的私钥和server的公钥;&gt;你会看到，在此次联机的服务器与客户端的密钥系统 (公钥+私钥) 并不一样，所以才称为非对称加密系统。开始双向加解密:&gt;服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密;&gt;客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探究Android OS 启动流程]]></title>
      <url>%2F2016%2F11%2F24%2Fandroid-1-%E6%8E%A2%E7%A9%B6Android%20OS%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[探究Android OS 启动流程一，前言为了更好地服务于Android应用层的开发，尝试理解整个Android OS系统的内部制、Android整个架构的思想以及各个模块的交互逻辑等等。Android系统涉及的层面过于复杂，从google官方的四层架构图(如下图)就能看出其复杂性.去深入理解每层每个模块的机制和原理不是一朝一夕的事,所以我们先从OS整个启动流程来窥探一二. NOTE:由于本人从源码Version4.4.2版本开始探索,博文中涉及到的具体类或者逻辑都是基于Android4.4.2,之所以没有探究最新的,是因为无论Android怎么迭代更新,其中内部机制的基本流程、骨干脉络大致相同的(也可能会有大的改动,比如Dalvik VM变成ART…). 二，理解Android启动过程我们试着探究OS启动流程时,我们总有很多疑问.我们带着问题去理解整个启动流程: 按下电源键到我们看到Android Launcher是一个怎么样的流程? 我们依次在屏幕上看到的各种logo、动画是什么?那个阶段现实的？ 我们写的app是怎么被安装到系统上的? 我们点击app的图标时又发生了什么? 等等… 我们先看一个大概的流程图,然后带着我的问题逐一去理解整个Android OS启动流程: tips:画图工具为Chrome 插件:gliffy 第一步:启动电源以及系统启动当我们按下电源后,引导芯片代码执行,然后加载引导程序到RAM执行. //TODO 这里面涉及到的BIOS/MBR等知识,不做探究…可以参考一下鸟哥的私房菜关于Linux的启动流程分析。因为Android是基于Linux2.6版本的，具体的流程可以参考一下。 第二步:Boot Loeader引导程序 在硬盘上第0磁道第一个扇区被称为MBR，即主引导记录，存放预启动信息以及分区表信息。 系统找到MBR后会将其复制到特定地址的物理内存中，物理内存上的内容就是 Boot Loeader; Boot Loeader的作用:检测外部的RAM以及加载一些有用的程序,设置网络、内存,初始化硬件(主板、键盘…)等,主要一点就是根据Boot Loeader内部的配置信息,找到内核镜像,然后将内核加载到内存. 第三步:Linux Kernel系统将内核加载到内存之后，并调用相关函数来启动一系列的初始化函数并初始化各种设备，比如设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init“文件，然后启动root进程或者系统的第一个进程。 第四步:init进程init是第一个进程。进程号为1。也是所有用户进程的父进程。 12shell@mako: # ps |grep init root 1 0 692 556 c012cbf0 0001a070 S /init init进程对应的文件./system/core/init/init.c,在其main()方法中我们可以看到主要有3个责任: 123* 挂载目录，比如比如/sys、/dev、/proc* 运行init.rc脚本* 提供属性服务 主要代码如下: 1234567891011121314151617181920212223242526272829303132int main(int argc, char **argv)&#123; .... mkdir("/dev", 0755); mkdir("/proc", 0755); mkdir("/sys", 0755); mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"); mkdir("/dev/pts", 0755); mkdir("/dev/socket", 0755); mount("devpts", "/dev/pts", "devpts", 0, NULL); mount("proc", "/proc", "proc", 0, NULL); mount("sysfs", "/sys", "sysfs", 0, NULL); .... klog_init();//初始化kernel log property_init();//属性服务初始化 .... //NOTE(ljs):解析脚本文件/init.rc init_parse_config_file("/init.rc"); .... //NOTE(ljs):执行rc文件中触发器为 on init的语句 action_for_each_trigger("init", action_add_queue_tail); .... //NOTE(ljs):android层第二个开机画面相关 queue_builtin_action(console_init_action, "console_init"); .... //NOTE(ljs):启动属性服务 queue_builtin_action(property_service_init_action, "property_service_init"); return 0;&#125; 具体的关于init.rc脚本，请阅读探究 init.rc 脚本。 具体的关于属性服务，请阅读探究 Android 属性服务。 init进程启动后会利用initr.rc孵化了Zygote进程,如下: 1234567service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 第五步:Zygote Zygote这个进程是非常重要的一个进程，Zygote进程的建立是真正的Android运行空间。我么利用ps命令可以看到关于Zygote进程的详细信息: 12shell@mako:/ # ps |grep zygote root 175 1 859220 41940 ffffffff 400ea6d8 S zygote Zygote,其最初的名字是app_process，通过直接调用pctrl把名字给改成了”Zygote”。 我们看一下其对应的源文件为:./frameworks/base/cmds/app_process/app_main.cpp 看一下其main()方法: 1234567891011121314151617int main(int argc, char* const argv[])&#123; .... AppRuntime runtime; ... if (zygote) &#123; //NOTE(ljs):AppRuntime runtime 即AndroidRuntime,在AndroidRuntime.cpp里有个start()---&gt;startVm() //NOTE(ljs):在ZygoteInit===&gt;main()中调用了方法startSystemServer( ); //NOTE(ljs):这个方法主要目的是加载了com.android.server.SystemServer.java //NOTE(ljs):这个类&lt;source-path&gt;/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java runtime.start("com.android.internal.os.ZygoteInit",startSystemServer ? "start-system-server" : ""); &#125; else&#123; ... &#125;&#125; 我们在看一下AndroidRuntime.cpp中的 1234567891011121314151617181920212223242526272829void AndroidRuntime::start(const char* className, const char* options)&#123; ... //NOTE(ljs):调用函数startVm()启动虚拟机 if (startVm(&amp;mJavaVM, &amp;env) != 0) &#123; return; &#125; onVmCreated(env); //NOTE(ljs):调用函数startReg()注册JNI方法 if (startReg(env) &lt; 0) &#123; ALOGE("Unable to register all android natives\n"); return; &#125; if (startClass == NULL) &#123; ... &#125; else &#123; ... if (startMeth == NULL) &#123; .... &#125; else &#123; //NOTE(ljs):调用了com.android.internal.os.ZygoteInit类的main()函数 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ...... &#125; &#125; ...&#125; 主要做了如下几个工作: 启动虚拟机 注册JNI 调用了com.android.internal.os.ZygoteInit类的main()函数 什么是AndroidRuntime？我们从上面Android体系架构图中可以看出，其就是为Android应用运行所需的运行时环境，包括Dalvik VM以及核心类库(java、JNI、libc等) 我们继续探究ZygoteInit.java的main(),主要工作已在代码中表明: 12345678910111213141516171819public static void main(String argv[]) &#123; ... //NOTE(ljs):创建了一个socket接口,用来和ActivityManagerService通讯 registerZygoteSocket(); ... //NOTE(ljs):来启动SystemServer组件 startSystemServer(); ... //NOTE(ljs):调用runSelectLoopMode函数进入一个无限循环在前面创建的socket接口上等待ActivityManagerService请求创建新的应用程序进程 runSelectLoop(); ... &#125; //TODO Zygote是处于什么目的提出来的？ 第六步:SystemServer我们继续分析SystemServer的main()方法: 123456789public static void main(String[] args) &#123; .... // NOTE(ljs):传说中的init1():开启了Native世界 nativeInit(); ... // NOTE(ljs):传说中的init2():开启java世界 ServerThread thr = new ServerThread(); thr.initAndLoop();&#125; 关于开启Native世界:见.frameworks/base/services/jni/com_android_server_SystemServer.cpp 12345678static void android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) &#123; char propBuf[PROPERTY_VALUE_MAX]; property_get("system_init.startsensorservice", propBuf, "1"); if (strcmp(propBuf, "1") == 0) &#123; // Start the sensor service SensorService::instantiate(); &#125;&#125; 作为应用层开发人员我们重点看一下传说中的init2():ServerThread.initAndLoop() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void initAndLoop() &#123; ... Looper.prepareMainLooper(); ... //NOTE(ljs):创建各种服务实例,初始化完成以后加入到ServiceManager中 Installer installer = null; .... IPackageManager pm = null;//包管理服务 Context context = null; //窗口管理系统服务 WindowManagerService wm = null; ... HandlerThread wmHandlerThread = new HandlerThread("WindowManager"); wmHandlerThread.start(); Handler wmHandler = new Handler(wmHandlerThread.getLooper()); wmHandler.post(new Runnable() &#123; @Override public void run() &#123; //Looper.myLooper().setMessageLogging(new LogPrinter(android.util.Log.DEBUG, TAG, android.util.Log.LOG_ID_SYSTEM)); android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DISPLAY); android.os.Process.setCanSelfBackground(false); // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, "Enabled StrictMode logging for WM Looper"); &#125; &#125; &#125;); ... //NOTE(ljs):通过线程(类AThread)初始化ActivityManagerService实例以及其他实例 context = ActivityManagerService.main(factoryTest); ... //NOTE(ljs):创建了一个PackageManagerService服务实例,然后把这个服务添加到ServiceManager中去 pm = PackageManagerService.main(context, installer, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore); ... //NOTE(ljs):ActivityManagerService作为ApplicationFramework最重要的服务 ActivityManagerService.setSystemProcess(); ... //NOTE(ljs):系统服务初始化准备就绪,通知各个模块 Slog.d("xxoo","ActivityManagerService.self().systemReady(Runnable r)系统服务初始化准备就绪,通知各个模块"); ActivityManagerService.self().systemReady(new Runnable() &#123; public void run() &#123; .... //NOTE(ljs):启动com.android.systemui startSystemUi(contextF); .... &#125; &#125;); ....&#125; 我们看到一大堆的服务和Manager,初始化服务,创建各种服务实例,如:电源、网络、Wifi、蓝牙，USB等,初始化完成以后加入到ServiceManager中，在系统服务器准备就绪后，调用startSystemUi()启动com.android.systemui服务，开始做一些与SystemBars、Recents、SettingsUI等先关工作。 关于com.android.systemui服务对应的是com.android.systemui.SystemUIService。源码路径为:/frameworks/base/packages/SystemUI/src/com/android/systemui/SystemUIService.javaTODO 关于这部分我们后续分析 下面我们进去ActivityManagerService.systemReady()看一看: 123456789101112131415public void systemReady(final Runnable goingCallback) &#123; .... //NOTE(ljs):android.intent.action.PRE_BOOT_COMPLETED这个广播是在核心系统启动完成后, //NOTE(ljs):在launcher启动前或在BOOT_COMPLETED广播发出前发出的广播 .... Intent intent = new Intent(Intent.ACTION_PRE_BOOT_COMPLETED); //NOTE(ljs):FLAG_RECEIVER_BOOT_UPGRADE这个标记位意味着什么？ intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE); .... //NOTE(ljs):内部调用了ActivityStack.resumeTopActivityLocked--&gt;ActivityStack.resumeTopActivityLocked()--&gt; //--&gt;ActivityStackSupervisor.resumeHomeActivity()--&gt;mService.startHomeActivityLocked() //这里的mService即AMS mStackSupervisor.resumeTopActivitiesLocked(); sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);&#125; 发送了android.intent.action.PRE_BOOT_COMPLETED广播，调用ActivityStack.resumeTopActivityLocked()，我们继续跟踪到ActivityStack.resumeTopActivityLocked(): 12345678910111213141516171819final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; .... .... // Find the first activity that is not finishing. // NOTE(ljs):调用函数topRunningActivityLocked返回的是当前系统Activity堆栈最顶端的Activity, // NOTE(ljs):由于此时还没有Activity被启动过,因此,返回值为null,即next变量的值为nul ActivityRecord next = topRunningActivityLocked(null); .... if (next == null) &#123; .... //NOTE(ljs):调用了ActivityStackSupervisor.resumeHomeActivity() return mStackSupervisor.resumeHomeActivity(prev); &#125; .... ....&#125; 最红我们由ActivityStackSupervisor.resumeHomeActivity()–&gt;AMS.startHomeActivityLocked()，我们分析一下这里面有我们要找的关键代码: 123456789101112131415161718192021222324boolean startHomeActivityLocked(int userId) &#123; ... //NOTE(ljs):发送开机广播 ensureBootCompleted(); .... //NOTE(ljs):1.获取一个CATEGORY_HOME类型的Intent;android.intent.category.HOME Intent intent = getHomeIntent(); //NOTE(ljs):2.向PackageManagerService查询Category类型为HOME的Activity ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //NOTE(ljs): 启动activity mStackSupervisor.startHomeActivity(intent, aInfo); &#125; &#125; return true;&#125; 函数首先通过getHomeIntent()获取一个android.intent.category.HOME类型的Intent,然后通过Intent.resolveActivityInfo函数向PackageManagerService查询Category类型为HOME的Activity，然后启动Activity。关于如何利用隐式意图启动Activity这里就不做讨论了。我们看一下Launcher的注册信息，详见/packages/apps/Launcher2/AndroidManifest.xml: 12345678910111213141516&lt;activity android:name="com.android.launcher2.Launcher" android:clearTaskOnLaunch="true" android:launchMode="singleTask" android:screenOrientation="nosensor" android:stateNotNeeded="true" android:theme="@style/Theme" android:windowSoftInputMode="adjustPan"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.HOME"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.MONKEY"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; OK，到此为止，我们分析到了AMS—&gt;启动Launcher。 第七步:Launcher的启动关于Launcher启动的细节以及UI方面的细节，因为涉及到的方面比较多，我会单独分析。应用层开发天天瞅着Launcher，还是需要了解一下其UI布局，管理机制等方面的。 //TODO 后续分析…… 第八步:我们自身的app的安装与启动8.1 app的安装详见探究 Android apk 安装过程 //TODO 后续分析…… NOTE 文章仅仅是分析了大体的流程和一小部分细节。还有大量的细节没有关注到，比如Init.rc、开机动画是怎么回事等等，我会在后期另开博文，并把链接加上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo -next 如何设置首页显示预览]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E9%A2%84%E8%A7%88%2F</url>
      <content type="text"><![CDATA[##hexo -next 如何设置首页显示预览 一，设置头像在next主题的_config.yml文件中，查找auto_excerpt，找到如下部分: 1234# Automatically Excerptauto_excerpt:enable: falselength: 150 只要把这个enable 改为true就可以实现首页显示预览，而不用全部显示.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 优化篇]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
      <content type="text"><![CDATA[##hexo 优化篇 ###一,设置头像在配置文件中添加: 1avatar: https://avatars3.githubusercontent.com/u/10328555?v=3&amp;s=460 # 头像的URL ###一,搜索引擎优化(SEO)添加百度主动推送代码,让搜索引擎最快发现文章. ###一,必备插件支持RSS：npm install hexo-generator-feed –save生成站点地图：npm install hexo-generator-sitemap –save生成百度站点地图：npm install hexo-generator-baidu-sitemap –saveHTML 压缩：npm install hexo-html-minifier –saveJavaScript 压缩：npm install hexo-uglify –saveCSS 压缩插件：npm install hexo-clean-css –saveSEO优化：npm install hexo-generator-seo-friendly-sitemap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 安装插件]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[##hexo 安装插件 ###一,sitemapsitemap是一种协议,他会让搜索引擎更好的收录你的网站;也是SEO (Search Engine Optimization)中的一个关键选项;安装命令如下: 1$ npm install hexo-generator-sitemap 修改_config.yml,添加如下内容: 1234567891011121314# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml ###二,feed//TODO …. ###三,多说评论 为博客集成评论系统,一般用多说.Hexo使用多说教程 ###四,cnzz统计/百度统计统计分析网站流量插件 ###五,JiaThis分享官方网站 六，图片储存–七牛七牛 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何搭建github pages+hexo博客]]></title>
      <url>%2F2016%2F11%2F23%2Fhexo-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAgithub-pages-hexo-%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[##利用Github Pages和Hexo搭建个人博客 ###一,安装git ###二,注册github账号 ###三,安装node.js node.js中文网站 node.js官网 ###四,了解Hexo Hexo官方文档 ###五,安装Hexo 12# 使用 npm 安装 Hexonpm install -g hexo-cli 安装查看一下版本: 1hexo version或 hexo v ###五,使用hexo创建项目12345678cd ~/githubhexo init hexo #执行init命令初始化到你指定的hexo目录cd hexo npm install #install before start blogginghexo generate #自动根据当前目录下文件,生成静态网页hexo server #运行本地服务hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 Terminal 提示如下: 123bogon:hexo luojunsheng$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 在本地跑一下hexo,在浏览器输入: 1http://localhost:4000/ 到此,我们在网页中看到了我们的blog(本地运行). ###六,添加部署代码在站点的-config.yml文件新增字段如下字段,讲Deployment站点部署到github 1234deploy: type: git repository: https://github.com/username/username.github.io.git branch: master 我的github为https://github.com/junshengluo/junshengluo.github.io然后部署 1234$ hexo g$ hexo d或者hexo g -d 如果出现下面的错误: 1Deployer not found: git 请运行如下命令: 1npm install hexo-deployer-git --save 然后访问浏览器:1username.github.io ###7,购买域名 阿里云 dnspod godaddy ###8,域名解析,讲域名指向github Pages 在source文件夹中新建一个CNAME文件(无后缀名),然后用文本编辑器打开,在首行添加你的网站域名,如http://xxxx.com,注意前面没有http://,也没有www. 在域名解析提供商 先添加一个CNAME,主机记录写@,后面记录值写上你的http://xxxx.github.io 再添加一个CNAME,主机记录写www,后面记录值也是http://xxxx.github.io 这样别人用www和不用www都能访问你的网站.也可以使用A记录,对应的记录值位github page的ip 等1分钟左右,刷新浏览器 1234@ A 192.30.252.153@ A 192.30.252.154@ CNAME username.github.iowww CNAME username.github.io.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何让wordpress支持代码缩进和高亮]]></title>
      <url>%2F2016%2F11%2F23%2Fwordpress-%E5%A6%82%E4%BD%95%E8%AE%A9wordpress%E6%94%AF%E6%8C%81%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%E5%92%8C%E9%AB%98%E4%BA%AE%2F</url>
      <content type="text"><![CDATA[##如何让wordpress支持代码缩进和高亮? wordpress的默认编辑器不支持代码代码缩进和高亮,需要插件WP Code Highlight支持 插件的下载 下载地址:https://wordpress.org/plugins/wp-code-highlight/ 下载后解压得到wp-code-highlight文件夹，上传至 /wp-content/plugins/ 目录，然后在后台“插件”那里启用。 对插件进行个性化的设置方法:登入后→设置→WP Code Highlight。 写文章时将代码放在&lt;pre&gt;和&lt;/pre&gt;中间即可 NOTE:Html编辑器中已经提供了一个名为WP-Code-Highlight的按钮，方便你插入代码 5.WP Code Highlight代码高亮演示 12345678910/** * Gets whether the TextView includes extra top and bottom padding to make * room for accents that go above the normal ascent and descent. * * @attr ref android.R.styleable#TextView_includeFontPadding * @see #setIncludeFontPadding(boolean) */public boolean getIncludeFontPadding() &#123; return mIncludePad;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F23%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
